This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-13T13:47:12.693Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
description.ext
functions/config/fn_initMissionConfig.sqf
functions/config/initPlatoonGroups.sqf
functions/debug/fn_dumpState.sqf
functions/debug/fn_initDebug.sqf
functions/init/fn_initPlatoonUnits.sqf
functions/medical/fn_addDeathHandler.sqf
functions/medical/fn_addLoadAction.sqf
functions/medical/fn_addLoadBodyAction.sqf
functions/medical/fn_addReviveAction.sqf
functions/medical/fn_addUnitTraumaStatus.sqf
functions/medical/fn_addUnloadBodyAction.sqf
functions/medical/fn_beginMedicalTreatmentAction.sqf
functions/medical/fn_checkUnitTraumaStatus.sqf
functions/medical/fn_handleUnitDeath.sqf
functions/medical/fn_initMedicalSystems.sqf
functions/medical/fn_loadCasualtyAction.sqf
functions/medical/fn_startRevivalProcess.sqf
scripts/state/platoon_assets.sqf

================================================================
Files
================================================================

================
File: description.ext
================
class CfgConstants 
{
    // General Mission Settings
    MISSION_NAME = "Dynamic Platoon Command";
    MISSION_AUTHOR = "Dylan Britz";
    
    // Medical System Constants
    class Medical {
        REVIVE_TIME_LIMIT = 600;     // 10 minutes in seconds
        REVIVE_TIME = 60;            // 60 seconds to revive
        MAX_REVIVE_DISTANCE = 20;     // meters from medical building
        SKILL_PENALTY = 0.1;         // 10% skill reduction after revival
        MAX_CASEVAC_DISTANCE = 10;   // meters from vehicle
        MAX_MEDICAL_FACILITY_CAPACITY = 2; // Number of patients that can be treated at once
    };

    // Resupply unit constants
    class SupplyPool {
        TRACKED_VEHICLE_POOL = 1;
        MRAP_VEHICLE_POOL = 15;
        HMG_VEHICLE_POOL = 10;
        GMG_VEHICLE_POOL = 7;
        QUAD_POOL = 20;
        AMMO_TRUCK_POOL = 25;
        MED_TRUCK_POOL = 5;
        REPAIR_TRUCK_POOL = 5;
        FUEL_TRUCK_POOL = 12;
        HMG_TURRET_POOL = 55;
        GMG_TURRET_POOL = 25;
        AT_TURRET_POOL = 15;
        MORTAR_TURRET_POOL = 15;
    };
};
class CfgFunctions
{
    class DPC
    {
        tag = "DPC";

        class Config {
            file = "functions\config";
            class initMissionConfig {
                postInit = 1;
            };
        };
        
        class Medical
        {
            file = "functions\medical";
            class addDeathHandler {};
            class addLoadAction {};
            class addLoadBodyAction {};
            class addReviveAction {};
            class addUnitTraumaStatus {};
            class addUnloadBodyAction {};
            class beginMedicalTreatmentAction {};
            class canLoadBody {};
            class canLoadCasualty {};
            class checkUnitTraumaStatus {};
            class handleUnitDeath {};
            class initMedicalSystems {
                postInit = 1;
            };
            class loadCasualtyAction {};
            class startReviveProcess {};
        };

        class Debug
        {
            file = "functions\debug";
            class dumpState {};
            class initDebug {
                postInit = 1;
            };
        }
    };
};

================
File: functions/config/fn_initMissionConfig.sqf
================
// File: functions\config\fn_initMissionConfig.sqf

// Initialize Global Mission State
if (isNil "DPC_MISSION_STATE") then {
    DPC_MISSION_STATE = createHashMap;
    publicVariable "DPC_MISSION_STATE";
};

if (isNil "DPC_PLATOON_ASSETS") then {
    DPC_PLATOON_ASSETS = createHashMap;
    publicVariable "DPC_PLATOON_ASSETS";
};

================
File: functions/config/initPlatoonGroups.sqf
================
// // File: functions\config\fn_initPlatoonGroups.sqf

// /*
//     Author: Your Name
//     Description: Initializes or replenishes a NATO infantry platoon
    
//     Parameters:
//         _spawnPos: Array/Object - Position to spawn units [x,y,z] or object
//         _replenish: Boolean - True to check and replenish existing groups
    
//     Returns: Array of groups created/replenished
    
//     Example:
//     [getMarkerPos "platoon_start", false] call DPC_fnc_initPlatoonGroups;
// */

// params [
//     ["_spawnPos", [0,0,0], [[],objNull]],
//     ["_replenish", false, [false]]
// ];

// // NATO Infantry unit types
// #define UNIT_OFFICER "B_officer_F"
// #define UNIT_SQL "B_Soldier_SL_F"
// #define UNIT_TL "B_Soldier_TL_F"
// #define UNIT_MEDIC "B_medic_F"
// #define UNIT_AR "B_soldier_AR_F"
// #define UNIT_GREN "B_Soldier_GL_F"
// #define UNIT_LAT "B_soldier_LAT_F"
// #define UNIT_RADIO "B_Soldier_lite_F"

// // Platoon structure definitions
// private _platoonStructure = [
//     // HQ Squad - 4 men
//     [
//         "HQ", [
//             [UNIT_OFFICER, "Platoon Commander"],
//             [UNIT_MEDIC, "Platoon Medic"],
//             [UNIT_RADIO, "Platoon RTO"],
//             [UNIT_TL, "Platoon Sergeant"]
//         ]
//     ],
//     // Three identical infantry squads - 8 men each
//     [
//         "Alpha", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Bravo", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Charlie", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ]
// ];

// // Convert spawn position
// _spawnPos = if (_spawnPos isEqualType objNull) then {
//     getPos _spawnPos
// } else {
//     _spawnPos
// };

// // Initialize platoon groups array if needed
// if (isNil "PLATOON_GROUPS" && !_replenish) then {
//     PLATOON_GROUPS = [];
// };

// // Function to create a single unit
// private _fnc_createUnit = {
//     params ["_type", "_role", "_group", "_pos"];
    
//     private _unit = _group createUnit [_type, _pos, [], 5, "NONE"];
//     _unit setRank "PRIVATE";
//     _unit setVariable ["DPC_Role", _role, true];  // Added true for global broadcast
    
//     // Set ranks based on role
//     switch (toLower _role) do {
//         case "platoon commander": { _unit setRank "LIEUTENANT" };
//         case "platoon sergeant": { _unit setRank "SERGEANT" };
//         case "squad leader": { _unit setRank "SERGEANT" };
//         case "team leader": { _unit setRank "CORPORAL" };
//         default { _unit setRank "PRIVATE" };
//     };
    
//     _unit
// };

// // Process each squad in the platoon structure
// {
//     _x params ["_squadName", "_composition"];
//     private "_group";
    
//     // Check if group exists when replenishing
//     if (_replenish) then {
//         {
//             if ((_x getVariable ["DPC_SquadName", ""]) == _squadName) exitWith {
//                 _group = _x;
//             };
//         } forEach PLATOON_GROUPS;
//     };
    
//     // Create new group if needed
//     if (isNil "_group" || {isNull _group}) then {
//         _group = createGroup [west, true];
//         _group setVariable ["DPC_SquadName", _squadName, true];  // Added true for global broadcast
//         PLATOON_GROUPS pushBack _group;
//     };
    
//     // Create or replenish units
//     {
//         _x params ["_type", "_role"];
        
//         // Check if we need this role when replenishing
//         private _needUnit = true;
//         if (_replenish) then {
//             {
//                 if (alive _x && {_x getVariable ["DPC_Role", ""] == _role}) exitWith {
//                     _needUnit = false;
//                 };
//             } forEach (units _group);
//         };
        
//         // Create unit if needed
//         if (_needUnit) then {
//             [_type, _role, _group, _spawnPos] call _fnc_createUnit;
//         };
//     } forEach _composition;
    
//     // Basic group settings
//     _group enableDynamicSimulation true;
//     _group setFormation "WEDGE";
    
// } forEach _platoonStructure;

// // Return the groups array
// PLATOON_GROUPS

================
File: functions/debug/fn_dumpState.sqf
================
// File: functions/debug/fn_dumpState.sqf

/*
    Author: Dylan Britz
    Description: Dumps the entire mission state to clipboard for debugging
    
    Parameters:
        _state: HashMap - The mission state hashmap to dump
    
    Returns: String - The formatted state dump text
    
    Example:
    [DPC_MISSION_STATE] call DPC_fnc_dumpState;
*/

params [["_state", createHashMap, [createHashMap]]];

private _text = "";

if (count _state == 0) then {
    hint "Mission State not initialized";
    _text = "ERROR: Mission State not initialized";
} else {
    private _stateKeys = keys _state;
    
    _text = "=== MISSION STATE DUMP ===\n";
    _text = _text + format["Timestamp: %1\n", [dayTime, "HH:MM:SS"] call BIS_fnc_timeToString];
    _text = _text + format["Number of Keys: %1\n\n", count _stateKeys];
    
    {
        private _key = _x;
        private _value = _state get _key;
        
        // Handle different value types
        switch (true) do {
            // Handle nested hashmaps
            case (_value isEqualType createHashMap): {
                _text = _text + format["=== %1 ===\n", _key];
                {
                    private _subKey = _x;
                    private _subValue = _value get _subKey;
                    _text = _text + format["  %1: %2\n", _subKey, str _subValue];
                } forEach (keys _value);
                _text = _text + "\n";
            };
            // Handle arrays
            case (_value isEqualType []): {
                _text = _text + format["%1: %2\n", _key, str _value];
            };
            // Handle objects
            case (_value isEqualType objNull): {
                _text = _text + format["%1: %2 (%3)\n", _key, typeOf _value, str _value];
            };
            // Handle everything else
            default {
                _text = _text + format["%1: %2\n", _key, str _value];
            };
        };
    } forEach _stateKeys;
    
    copyToClipboard _text;
    hint "Mission State dumped to clipboard";
};

// Return formatted text
_text

================
File: functions/debug/fn_initDebug.sqf
================
player addAction [
    "Dump Mission State",
    {
        [DPC_MISSION_STATE] call DPC_fnc_dumpState;
    }, 
    nil, 
    1.5, 
    true, 
    true, 
    "",
    "true", // Condition
    5 // Radius
];

player addAction [
    "Dump Platoon State", 
    {
        [DPC_PLATOON_ASSETS] call DPC_fnc_dumpState;
    }, 
    nil, 
    1.5, 
    true, 
    true, 
    "",
    "true", // Condition
    5 // Radius
];

================
File: functions/init/fn_initPlatoonUnits.sqf
================
// File: functions\init\fn_initPlatoonUnits.sqf

/*
    Author: Your Name
    Description: Initializes platoon units into mission state and adds necessary event handlers
    
    Parameters:
        _groups: Array - Array of groups to initialize [group1, group2, ...]
    
    Returns: None
    
    Example:
    [PLATOON_GROUPS] call DPC_fnc_initPlatoonUnits;
*/

params [["_groups", [], [[]]]];

private _medicalState = DPC_MISSION_STATE get "sys_medical";
if (isNil "_medicalState") then {
    _medicalState = createHashMap;
    DPC_MISSION_STATE set ["sys_medical", _medicalState];
    _medicalState set ["dead_units", []];
};

// Get platoon state
private _platoonState = DPC_MISSION_STATE get "platoon";
if (isNil "_platoonState") then {
    _platoonState = createHashMap;
    DPC_MISSION_STATE set ["platoon", _platoonState];
    _platoonState set ["all_units", []];
    _platoonState set ["active_units", []];
};

// Process each group
{
    private _group = _x;
    private _groupUnits = units _group;
    
    // Add units to platoon state
    {
        private _unit = _x;
        
        // Skip if unit is already initialized
        if !(_unit getVariable ["DPC_initialized", false]) then {
            // Add to all units array if not already present
            if !(_unit in (_platoonState get "all_units")) then {
                (_platoonState get "all_units") pushBack _unit;
            };
            
            // Add to active units if alive
            if (alive _unit) then {
                (_platoonState get "active_units") pushBack _unit;
            };
            
            // Add death event handler
            if (!isPlayer _unit) then {
                private _handlerId = _unit addEventHandler ["Killed", {
                    params ["_unit"];
                    [_unit] call DPC_fnc_handleUnitDeath;
                }];
                _unit setVariable ["DPC_deathHandler", _handlerId];
            };
            
            // Mark as initialized
            _unit setVariable ["DPC_initialized", true];
            
            // Set additional unit variables as needed
            _unit setVariable ["DPC_originalGroup", group _unit];
            _unit setVariable ["DPC_originalRole", roleDescription _unit];
        };
    } forEach _groupUnits;
} forEach _groups;

// Debug output
// if (DPC_DEBUG) then {
//     private _totalUnits = count (_platoonState get "all_units");
//     private _activeUnits = count (_platoonState get "active_units");
//     systemChat format ["Platoon initialized: %1 total units, %2 active", _totalUnits, _activeUnits];
    
//     // Detailed debug dump
//     [DPC_MISSION_STATE] call DPC_fnc_dumpState;
// };

================
File: functions/medical/fn_addDeathHandler.sqf
================
// Add death handlers to all existing units on the players side

private _eligibleUnits = allUnits select {
    private _isValidUnit = 
        alive _x && 
        {!isPlayer _x} && 
        {side _x == playerSide} && 
        {!(_x getVariable ["DPC_IS_EXCLUDED", false])} &&
        {isNil {_x getVariable "DPC_traumaHandler"}};

    if (!_isValidUnit) then {
        diag_log format ["[DPC] Warning: Invalid unit found: %1", _x];
    };

    _isValidUnit
};

{
    private _handlerId = _x addEventHandler ["HandleDamage", {
            params ["_unit", "_selection", "_damage"];
                if (_damage >= 0.9) then {
                    [_unit] call DPC_fnc_handleUnitDeath;
                };
        }];
    _x setVariable ["DPC_traumaHandler", _handlerId];
} forEach _eligibleUnits;

================
File: functions/medical/fn_addLoadAction.sqf
================
// Add load actions to appropriate vehicles
{
    if (_x isKindOf "Car" || _x isKindOf "Tank" || _x isKindOf "Air") then {
        [_x] call DPC_fnc_addLoadBodyAction;
    };
} forEach vehicles;

================
File: functions/medical/fn_addLoadBodyAction.sqf
================
// File: functions\medical\fn_addLoadBodyAction.sqf
params ["_vehicle"];
private _conditionStr = "!isNil 'DPC_MISSION_STATE' && {count (nearestObjects [_target, ['Man'], 10] select {_x in (DPC_MISSION_STATE get 'SYS_MEDICAL' get 'TRAUMA_UNITS') && !(_x in (crew _target))}) > 0} && {_target emptyPositions 'cargo' > 0}";

_vehicle addAction [
    "Load Casualty",
    DPC_fnc_loadCasualtyAction,
    nil,
    1.5,
    true,
    true,
    "",
    _conditionStr
];

================
File: functions/medical/fn_addReviveAction.sqf
================
// File: functions\medical\fn_addReviveAction.sqf
params ["_building"];

// Set maximum number of simultaneous treatments
private _maxTreatments = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "MAX_MEDICAL_FACILITY_CAPACITY");
private _casevacDistance = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "MAX_CASEVAC_DISTANCE");
private _reviveTime = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME_LIMIT");
private _skillPenalty = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "SKILL_PENALTY");

_building addAction [
    "Begin Medical Treatment",
    {
        params ["_building", "_caller", "_actionId"];
        private _reviveTime = _this select 3 select 0;
        private _skillPenalty = _this select 3 select 1;
        private _casevacDistance = _this select 3 select 2;
        private _maxTreatments = _this select 3 select 3;
        
        // Count current treatments
        private _currentTreatments = count ((nearestObjects [_building, ["Man"], 15]) select {
            !isNil {_x getVariable "dpc_reviveProgress"}
        });
        
        // Get all dead units near building not already being treated
        private _nearbyDead = (nearestObjects [_building, ["Man"], _casevacDistance]) select {
            _x in (DPC_MISSION_STATE get "SYS_MEDICAL" get "TRAUMA_UNITS") &&
            isNil {_x getVariable "dpc_reviveProgress"}
        };
        
        // Calculate how many more we can treat
        private _availableSlots = _maxTreatments - _currentTreatments;
        
        if (_availableSlots <= 0) exitWith {
            systemChat "Medical facility at maximum capacity (2 patients)";
        };
        
        if (count _nearbyDead > 0) then {
            // Limit number of new treatments to available slots
            private _unitsToTreat = _nearbyDead select [0, _availableSlots];
            
            // Start revival process for each dead unit
            {
                private _deadUnit = _x;
                
                // Start revival process and pass the needed variables
                [_deadUnit, _building, _reviveTime, _skillPenalty] spawn {
                    params ["_unit", "_building", "_reviveTime", "_skillPenalty"];
                    private _startTime = time;
                    
                    // Create progress tracking variable
                    _unit setVariable ["dpc_reviveProgress", 0, true];
                    
                    // Progress loop
                    while {time - _startTime < 60} do {
                        // Update progress
                        private _progress = ((time - _startTime) / 60) * 100;
                        _unit setVariable ["dpc_reviveProgress", _progress, true];
                        
                        // Display progress for each unit
                        systemChat format ["%1 Treatment Progress: %2%3", name _unit, floor _progress, "%"];
                        sleep 1; // Update every 5 seconds
                    };
                    
                    // Revival complete
                    // Remove from dead units
                    private _traumaUnits = DPC_MISSION_STATE get "SYS_MEDICAL" get "TRAUMA_UNITS";
                    _traumaUnits = _traumaUnits - [_unit];
                    (DPC_MISSION_STATE get "SYS_MEDICAL") set ["TRAUMA_UNITS", _traumaUnits];
                    
                    // Revive unit
                    _unit setDamage 0;
                    _unit setUnconscious false;
                    _unit allowDamage true;
                    _unit enableAI "ALL"; // Re-enable AI
                    _unit switchMove ""; // Reset animation
                    
                    // set skill penalty
                    _unit setSkill ((skill _unit) - _skillPenalty);
                    
                    // Reset death time (do this before clearing reviveProgress)
                    _unit setVariable ["dpc_traumaStart", nil, true];
                    
                    // Notify success
                    systemChat format ["%1 has been revived", name _unit];
                    
                    // Clear variables, do not set ot nil. This is important for the condition check
                    _unit setVariable ["dpc_reviveProgress", nil, true];
                };
            } forEach _unitsToTreat;
            
            systemChat format ["Beginning treatment of %1 casualties", count _unitsToTreat];
        } else {
            systemChat "No casualties within range of medical facility";
        };
    },
    [_reviveTime, _skillPenalty, _casevacDistance, _maxTreatments],  // Pass these variables as arguments
    1.5,
    true,
    true,
    "",
    // Condition: Check for any nearby dead units not being treated AND facility not at capacity
    format ["private _currentTreatments = count ((nearestObjects [_target, ['Man'], 10]) select {!isNil {_x getVariable 'dpc_reviveProgress'}}); _currentTreatments < %1 && {count ((nearestObjects [_target, ['Man'], %2]) select {_x in (DPC_MISSION_STATE get 'SYS_MEDICAL' get 'TRAUMA_UNITS') && isNil {_x getVariable 'dpc_reviveProgress'}}) > 0}", _maxTreatments, _casevacDistance]
];

================
File: functions/medical/fn_addUnitTraumaStatus.sqf
================
params ["_unit", "_reviveTimeLimit"];
private _traumaStart = _unit getVariable "dpc_traumaStart";

waitUntil {
    sleep 1;
    if (!isNil "_traumaStart" &&
        (time - _traumaStart >= _reviveTimeLimit)) then {
        private _medicalState = DPC_MISSION_STATE get "SYS_MEDICAL";
        private _traumaUnits = _medicalState get "TRAUMA_UNITS";
        _traumaUnits = _traumaUnits - [_unit];
        _medicalState set ["TRAUMA_UNITS", _traumaUnits];

        {_unit removeAction _x} forEach (actionIDs _unit); // Remove all actions
        _unit enableAI "ALL";
        _unit setDamage 1;
        true
    } else {
        false
    };
};

================
File: functions/medical/fn_addUnloadBodyAction.sqf
================
params ["_unit"];

_unit addEventHandler ["GetOutMan", {
    params ["_unit", "_role", "_vehicle", "_turret"];
    _vehicle lockCargo false;
}];

================
File: functions/medical/fn_beginMedicalTreatmentAction.sqf
================
// functions/actions/medical/fn_beginMedicalTreatmentAction.sqf
params [
    "_building", 
    "_caller", 
    "_actionId",
    ["_args", [], [[]]]
];

_args params [
    ["_reviveTime", 600],
    ["_skillPenalty", 0.1],
    ["_casevacDistance", 15],
    ["_maxTreatments", 2]
];

private _currentTreatments = count ((nearestObjects [_building, ["Man"], 15]) select {
    !isNil {_x getVariable "dpc_reviveProgress"}
});

private _nearbyDead = (nearestObjects [_building, ["Man"], _casevacDistance]) select {
    _x in (DPC_MISSION_STATE get "SYS_MEDICAL" get "TRAUMA_UNITS") &&
    isNil {_x getVariable "dpc_reviveProgress"}
};

private _availableSlots = _maxTreatments - _currentTreatments;

if (_availableSlots <= 0) exitWith {
    systemChat "Medical facility at maximum capacity (2 patients)";
};

if (count _nearbyDead > 0) then {
    private _unitsToTreat = _nearbyDead select [0, _availableSlots];
    
    {
        [_x, _building, _reviveTime, _skillPenalty] spawn DPC_fnc_startRevivalProcess;
    } forEach _unitsToTreat;
    
    systemChat format ["Beginning treatment of %1 casualties", count _unitsToTreat];
} else {
    systemChat "No casualties within range of medical facility";
};

================
File: functions/medical/fn_checkUnitTraumaStatus.sqf
================
params ["_target", "_caller", "_id", "_arguments"];
private _reviveTimeLimit = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME_LIMIT"); // 600
private _traumaStart = _target getVariable "dpc_traumaStart"; // 5
private _traumaTime = time - _traumaStart; // 15 - 5 = 10
private _traumaTimeLeft = _reviveTimeLimit - _traumaTime; // 600 - 10 = 590 seconds left
private _unitReviveTime = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME"); // 60 seconds
// Format time with leading zeros
private _minutes = floor(_traumaTimeLeft / 60); // 205 / 60 = 3
private _seconds = floor(_traumaTimeLeft % 60); // 205 % 60 = 25
private _timeStr = format ["%1:%2", _minutes,_seconds]; // 3:25

// Find nearest medical vehicle/facility
private _nearestMedical = trauma_unit;
private _medicalDist = if (!isNull _nearestMedical) then {
    round(_target distance _nearestMedical)
} else {
    "NO MEDICAL FACILITY NEARBY"
};

hint parseText format [
    "<t size='1.2' color='#ff0000'>URGENT CASUALTY STATUS</t><br/><br/>" +
    "Time Until Critical: %1<br/>" +
    "Distance to FOB: %2m<br/>" +
    "Status: URGENT - Immediate CASEVAC Required",
    _timeStr,
    _medicalDist
];

================
File: functions/medical/fn_handleUnitDeath.sqf
================
// File: functions\medical\fn_handleUnitDeath.sqf
params ["_unit"];

if(!isNil "DPC_MISSION_STATE") then {
    private _medicalState = DPC_MISSION_STATE get "SYS_MEDICAL";
    private _traumaUnits = _medicalState get "TRAUMA_UNITS";
    private _reviveTimeLimit = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME_LIMIT");

    if (!isPlayer _unit) then {
        _unit allowDamage false;
        _unit setUnconscious true;
        _unit disableAI "ALL";
        _unit enableAI "ANIM";
        _unit setVariable ["dpc_traumaStart", time]; // 5
        _traumaUnits pushBack _unit;
        // add action to view trauma status
        _unit addAction [
            "<t color='#ff0000'>Check URGENT Casualty</t>",
            DPC_fnc_checkUnitTraumaStatus,
            nil,
            10,
            false,
            true,
            "",
            "_this distance _target < 2"
        ];
        [_unit, _reviveTimeLimit] spawn {
            params ["_unit", "_reviveTimeLimit"];
            [_unit, _reviveTimeLimit] call DPC_fnc_addUnitTraumaStatus;
        };
    };
};

================
File: functions/medical/fn_initMedicalSystems.sqf
================
// File: functions\medical\fn_initMedicalSystem.sqf
// Initialize medical state if not exists
if (isNil {DPC_MISSION_STATE get "SYS_MEDICAL"}) then {
    DPC_MISSION_STATE set ["SYS_MEDICAL", createHashMap];
    (DPC_MISSION_STATE get "SYS_MEDICAL") set ["TRAUMA_UNITS", []];
};

[] call DPC_fnc_addDeathHandler;
[] call DPC_fnc_addLoadAction;
// in game building with variable name trauma_unit
[trauma_unit] call DPC_fnc_addReviveAction;

================
File: functions/medical/fn_loadCasualtyAction.sqf
================
params ["_vehicle", "_caller", "_actionId", "_deadUnit"];

private _traumaUnits = DPC_MISSION_STATE get "SYS_MEDICAL" get "TRAUMA_UNITS";
private _nearestDead = objNull;

if (_vehicle emptyPositions "cargo" == 0) exitWith {
    systemChat "Vehicle cargo is full!";
};

{
    if (_x distance _vehicle < 10 && 
        {!(_x in (crew _vehicle))} && 
        {_x getVariable ["dpc_traumaStart", -1] != -1}) exitWith {
        _nearestDead = _x;
    };
} forEach _traumaUnits;

if (!isNull _nearestDead) then {
    _nearestDead moveInCargo _vehicle;
    _nearestDead switchMove "KIA_passenger_boat_holdleft";
    _cargoIndex = _vehicle getCargoIndex _nearestDead;
    _vehicle lockCargo [_cargoIndex, true];
    [_nearestDead] call DPC_fnc_addUnloadBodyAction;
    
    systemChat format ["Vehicle now has %1 passenger seats remaining", 
        (_vehicle emptyPositions "cargo")];
    
    if (_vehicle emptyPositions "cargo" == 0) then {
        _vehicle removeAction _actionId;
    };
};

================
File: functions/medical/fn_startRevivalProcess.sqf
================
params ["_unit", "_building", "_reviveTime", "_skillPenalty"];

private _startTime = time;
_unit setVariable ["dpc_reviveProgress", 0, true];

while {time - _startTime < 60} do {
    private _progress = ((time - _startTime) / 60) * 100;
    _unit setVariable ["dpc_reviveProgress", _progress, true];
    systemChat format ["%1 Treatment Progress: %2%3", name _unit, floor _progress, "%"];
    sleep 1;
};

// Remove from trauma units
private _traumaUnits = DPC_MISSION_STATE get "SYS_MEDICAL" get "TRAUMA_UNITS";
_traumaUnits = _traumaUnits - [_unit];
(DPC_MISSION_STATE get "SYS_MEDICAL") set ["TRAUMA_UNITS", _traumaUnits];

// Revive unit
_unit setDamage 0;
_unit setUnconscious false;
_unit allowDamage true;
_unit enableAI "ALL";
_unit switchMove "";
_unit setSkill ((skill _unit) - _skillPenalty);
_unit setVariable ["dpc_traumaStart", nil, true];

systemChat format ["%1 has been revived", name _unit];
_unit setVariable ["dpc_reviveProgress", nil, true];

================
File: scripts/state/platoon_assets.sqf
================
DPC_PLATOON_ASSETS set ["veh_supply", createHashMap];
DPC_PLATOON_ASSETS set ["combat_vehicles", createHashMap];
DPC_PLATOON_ASSETS set ["transport_vehicles", createHashMap];
DPC_PLATOON_ASSETS set ["utility_vehicles", createHashMap];
DPC_PLATOON_ASSETS set ["turrets", createHashMap];

private _trackedVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "TRACKED_VEHICLE_POOL");
private _mrapVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MRAP_VEHICLE_POOL");
private _hmgVehiclePool =  getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "HMG_VEHICLE_POOL");
private _gmgVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "GMG_VEHICLE_POOL");
private _quadPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "QUAD_POOL");
private _ammoTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "AMMO_TRUCK_POOL"); 
private _medTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MED_TRUCK_POOL"); 
private _repairTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "REPAIR_TRUCK_POOL"); 
private _fuelTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "FUEL_TRUCK_POOL"); 
private _hmgTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "HMG_TURRET_POOL"); 
private _gmgTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "GMG_TURRET_POOL"); 
private _atTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "AT_TURRET_POOL"); 
private _mortarTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MORTAR_TURRET_POOL"); 

/*
#######################
#####
# Supply
#####
#######################
*/

private _veh_supply = DPC_PLATOON_ASSETS get "veh_supply";
_veh_supply set ["spawn_point", [14750.6,17085.3]];
_veh_supply set ["last_used", 0];
_veh_supply set ["cooldown", 60];

/*
#######################
#####
# Combat Vehicles
#####
#######################
*/

(DPC_PLATOON_ASSETS get "combat_vehicles") set ["pool", createHashMap];

private _com_pool = (DPC_PLATOON_ASSETS get "combat_vehicles") get "pool";
// [vehicle class, available units, active units]
_com_pool set ["B_APC_Tracked_01_rcws_F",[_trackedVehiclePool, 1]];
_com_pool set ["B_MRAP_01_hmg_F", [_hmgVehiclePool, 3]];
_com_pool set ["B_MRAP_01_gmg_F",[_gmgVehiclePool, 1]];

/*
#######################
#####
# Transport Vehicles
#####
#######################
*/

(DPC_PLATOON_ASSETS get "transport_vehicles") set ["pool", createHashMap];

private _trans_pool = (DPC_PLATOON_ASSETS get "transport_vehicles") get "pool";
_trans_pool set ["B_Quadbike_01_F", [_quadPool, 2]];
_trans_pool set ["B_MRAP_01_F", [_mrapVehiclePool, 2]];

/*
#######################
#####
# Utility Vehicles
#####
#######################
*/

(DPC_PLATOON_ASSETS get "utility_vehicles") set ["pool", createHashMap];

private _util_pool = (DPC_PLATOON_ASSETS get "utility_vehicles") get "pool";
_util_pool set ["B_Truck_01_ammo_F", [_ammoTruckPool, 1]];
_util_pool set ["B_Truck_01_medical_F",[_medTruckPool, 1]];
_util_pool set ["B_Truck_01_Repair_F",[_repairTruckPool, 1]];
_util_pool set ["B_Truck_01_fuel_F",[_fuelTruckPool, 1]];

/*
#######################
#####
# Turrets
#####
#######################
*/

(DPC_PLATOON_ASSETS get "turrets") set ["pool", createHashMap];

private _tur_pool = (DPC_PLATOON_ASSETS get "turrets") get "pool";
_tur_pool set ["B_HMG_01_high_F", [_hmgTurretPool, 3]];
_tur_pool set ["B_GMG_01_high_F", [_gmgTurretPool, 2]];
_tur_pool set ["B_static_AT_F", [_atTurretPool, 3]];
_tur_pool set ["B_Mortar_01_F", [_mortarTurretPool, 2]];

publicVariable "DPC_PLATOON_ASSETS";
