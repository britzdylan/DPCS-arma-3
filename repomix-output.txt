This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-20T16:58:28.625Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
description.ext
functions/medical/fn_addDeathHandler.sqf
functions/medical/fn_addLoadAction.sqf
functions/medical/fn_addLoadBodyAction.sqf
functions/medical/fn_addReviveAction.sqf
functions/medical/fn_addUnitTraumaStatus.sqf
functions/medical/fn_addUnloadBodyAction.sqf
functions/medical/fn_checkUnitTraumaStatus.sqf
functions/medical/fn_handleUnitDeath.sqf
functions/medical/fn_initMedicalSystems.sqf
functions/medical/fn_loadCasualtyAction.sqf
functions/medical/fn_startSurgeryAmbientAnim.sqf
functions/supply/fn_addPlatoonGear.sqf
functions/supply/fn_requestVehicle.sqf
functions/supply/fn_turretsSupply.sqf
functions/util/fn_addStaticManipulation.sqf
functions/util/fn_adjustStaticHeight.sqf
functions/util/fn_carryStatic.sqf
functions/util/fn_dropStatic.sqf
functions/util/fn_isCarrying.sqf
functions/util/fn_processAllStatics.sqf
functions/util/fn_slingLoadVehicle.sqf
initPlatoonGroups.sqf
ui/controls.hpp
ui/dialogs/artillery_dialog.hpp

================================================================
Files
================================================================

================
File: description.ext
================
#include "\a3\ui_f\hpp\defineCommonGrids.inc"
#include "\a3\ui_f\hpp\defineCommonColors.inc"
#include "ui\dialogs\artillery_dialog.hpp"

class CfgConstants 
{
    // General Mission Settings
    class DPCS_CONFIG {
        MISSION_NAME = "DPCS: Dynamic Platoon Command System";
        MISSION_AUTHOR = "Dylan Britz";
        ENABLED = 1; // Enable the DPCS system
        DEBUG = 1; // Enable debug mode
        DPCS_MEDICAL = 1; // Enable the medical system
        DPCS_FIRE_SUPPORT = 1; // Enable the fire support system
        DPCS_SUPPLY = 1; // Enable the supply system
        DPCS_TRANSPORT = 1; // Enable the transport system
    }

    // Resupply unit constants
    class SupplyPool {
        TRACKED_VEHICLE_POOL = 1;
        MRAP_VEHICLE_POOL = 12;
        HMG_VEHICLE_POOL = 6;
        GMG_VEHICLE_POOL = 3;
        QUAD_POOL = 20;
    };
};

class CfgFunctions
{
    class DPC
    {
        tag = "DPC";
        
        class Medical
        {
            file = "functions\medical";
            class addDeathHandler {};
            class addLoadAction {};
            class addLoadBodyAction {};
            class addReviveAction {};
            class addUnitTraumaStatus {};
            class addUnloadBodyAction {};
            class checkUnitTraumaStatus {};
            class handleUnitDeath {};
            class initMedicalSystems {
                postInit = 1;
            };
            class loadCasualtyAction {};
            class startSurgeryAmbientAnim {};
        };

        class Supply
        {
            file = "functions\supply";
            class turretsSupply {};
            class addPlatoonGear {};
            class requestVehicle {};
        }

        class Util
        {
            file = "functions\util";
            class addStaticManipulation {};
            class carryStatic {};
            class dropStatic {};
            class isCarrying {};
            class adjustStaticHeight {};
            class slingLoadVehicle {};
            class processAllStatics {
                postInit = 1;
            };
        };

        // class FireSupport 
        // {
        //     file = "functions\fire_support";
        //     class initArtillerySystem {
        //         postInit = 1;
        //     };
        //     class openArtilleryMenu {};
        //     class updateArtilleryAmmoUI {};
        //     class getArtilleryAmmo {};
        //     class onAmmoSelect {};
        //     class openMapForTarget {};
        // };
    };
};

================
File: functions/medical/fn_addDeathHandler.sqf
================
// Add death handlers to all existing units on the players side

private _eligibleUnits = allUnits select {
    private _isValidUnit = 
        alive _x && 
        {!isPlayer _x} && 
        {side _x == playerSide} && 
        {!(_x getVariable ["DPC_SYSMED_EXCLUDE", false])} &&
        {isNil {_x getVariable "DPC_SYSMED_TRAUMA_HANDLER"}};

    if (!_isValidUnit) then {
        diag_log format ["[DPC: SYSMED] Warning: Invalid unit found: %1", _x];
    };

    _isValidUnit
};

{
    private _handlerId = _x addEventHandler ["HandleDamage", {
            params ["_unit", "_selection", "_damage"];
                if (_damage >= 0.9) then {
                    [_unit] call DPC_fnc_handleUnitDeath;
                };
        }];
    _x setVariable ["DPC_SYSMED_TRAUMA_HANDLER", _handlerId];
} forEach _eligibleUnits;

================
File: functions/medical/fn_addLoadAction.sqf
================
// Add load actions to appropriate vehicles
{
    if (_x isKindOf "Car" || _x isKindOf "Tank" || _x isKindOf "Air") then {
        [_x] call DPC_fnc_addLoadBodyAction;
    };
} forEach vehicles;

================
File: functions/medical/fn_addLoadBodyAction.sqf
================
// File: functions\medical\fn_addLoadBodyAction.sqf
params ["_vehicle"];
private _conditionStr = "
private _nearbyUnits = nearestObjects [_target, ['Man'], DPCS_SYSMED_MAX_CASEVAC_DISTANCE];
private _loadableCasualties = count (_nearbyUnits select {
    _x in DPCS_SYSMED_TRAUMA_UNITS && 
    !(_x in (crew _target)) &&
    isNil {_x getVariable 'DPCS_SYSMED_REVIVE_PROGRESS'}
}) > 0;
_loadableCasualties && {_target emptyPositions 'cargo' > 0}
";

_vehicle addAction [
    "Load Casualty",
    DPC_fnc_loadCasualtyAction,
    nil,
    1.5,
    true,
    true,
    "",
    _conditionStr
];

================
File: functions/medical/fn_addReviveAction.sqf
================
// File: functions\medical\fn_addReviveAction.sqf
params ["_building"];

_building addAction [
    "Begin Medical Treatment",
    {
        params ["_building", "_caller", "_actionId"];
        // Count current treatments
        private _currentTreatments = count ((nearestObjects [_building, ["Man"], DPCS_SYSMED_MAX_REVIVE_DISTANCE]) select {
            !isNil {_x getVariable "DPCS_SYSMED_REVIVE_PROGRESS"}
        });
        DPCS_SYSMED_ACTIVE_TREATMENTS = _currentTreatments;

        
        // Get all dead units near building not already being treated
        private _nearbyDead = (nearestObjects [_building, ["Man"], DPCS_SYSMED_MAX_REVIVE_DISTANCE]) select {
            _x in (DPCS_SYSMED_TRAUMA_UNITS) &&
            isNil {_x getVariable "DPCS_SYSMED_REVIVE_PROGRESS"}
        };
        
        // Calculate how many more we can treat
        private _availableSlots = DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY - _currentTreatments;
        
        if (_availableSlots <= 0) exitWith {
            systemChat format ["Medical facility at maximum capacity (%1 patients)", DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY];
        };
        
        if (count _nearbyDead > 0) then {
            // Limit number of new treatments to available slots
            private _unitsToTreat = _nearbyDead select [0, _availableSlots];
            // Start revival process for each dead unit
            {
                private _deadUnit = _x;
                 DPCS_SYSMED_ACTIVE_TREATMENTS = DPCS_SYSMED_ACTIVE_TREATMENTS + 1;
                // Start revival process and pass the needed variables
                [_deadUnit, _building] spawn {
                    params ["_unit", "_building"];
                    private _startTime = time;
                    
                    // Create progress tracking variable
                    _unit hideObject true;
                    _unit enableSimulation false;
                    _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", 0, true];
                    
                    // Progress loop
                    while {time - _startTime < DPCS_SYSMED_REVIVE_TIME} do {
                        // Update progress
                        private _progress = ((time - _startTime) / DPCS_SYSMED_REVIVE_TIME) * 100;
                        _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", _progress, true];
                        
                        // Display progress for each unit
                        systemChat format ["%1 Treatment Progress: %2%3", name _unit, floor _progress, "%"];
                        sleep 5; // Update every 5 seconds
                    };

                    DPCS_SYSMED_TRAUMA_UNITS = DPCS_SYSMED_TRAUMA_UNITS - [_unit];
                    _unit setDamage 0;
                    _unit setUnconscious false;
                    _unit allowDamage true;
                    _unit switchMove ""; // Reset animation
                    _unit enableAI "ALL"; // Re-enable AI
                    _unit enableSimulation true;
                    _unit hideObject false;
                    {_unit removeAction _x} forEach (actionIDs _unit); // Remove all actions
                    _unit setSkill ((skill _unit) - DPCS_SYSMED_SKILL_PENALTY);
                    _unit setVariable ["DPCS_SYSMED_TRAUMA_START", nil, true];
                    systemChat format ["%1 has been revived", name _unit];
                    _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", nil, true];
                    DPCS_SYSMED_ACTIVE_TREATMENTS = DPCS_SYSMED_ACTIVE_TREATMENTS - 1;
                };
            } forEach _unitsToTreat;
            
            systemChat format ["Beginning treatment of %1 casualties", count _unitsToTreat];
        } else {
            systemChat "No casualties within range of medical facility";
        };
    },
    [],
    1.5,
    true,
    true,
    "",
    // Condition: Check for any nearby dead units not being treated AND facility not at capacity
    "
    private _nearbyUnits = nearestObjects [_target, ['Man'], DPCS_SYSMED_MAX_REVIVE_DISTANCE];
    private _currentTreatments = count (_nearbyUnits select {!isNil {_x getVariable 'DPCS_SYSMED_REVIVE_PROGRESS'}});
    private _hasUntreatedCasualties = count (_nearbyUnits select {
    _x in DPCS_SYSMED_TRAUMA_UNITS && 
    isNil {_x getVariable 'DPCS_SYSMED_REVIVE_PROGRESS'}
    }) > 0;
    _currentTreatments < DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY && _hasUntreatedCasualties
    "
];

================
File: functions/medical/fn_addUnitTraumaStatus.sqf
================
params ["_unit", "_reviveTimeLimit"];
private _traumaStart = _unit getVariable "DPCS_SYSMED_TRAUMA_START";

waitUntil {
    sleep 1;
    if (!isNil "_traumaStart" &&
        (time - _traumaStart >= _reviveTimeLimit)) then {
        DPCS_SYSMED_TRAUMA_UNITS = DPCS_SYSMED_TRAUMA_UNITS - [_unit];

        {_unit removeAction _x} forEach (actionIDs _unit); // Remove all actions
        _unit enableAI "ALL";
        _unit setDamage 1;
        _unit setVariable ["DPCS_SYSMED_TRAUMA_START", nil];
        _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", nil];
        true
    } else {
        false
    };
};

================
File: functions/medical/fn_addUnloadBodyAction.sqf
================
params ["_unit"];

_unit addEventHandler ["GetOutMan", {
    params ["_unit", "_role", "_vehicle", "_turret"];
    _vehicle lockCargo false;
}];

================
File: functions/medical/fn_checkUnitTraumaStatus.sqf
================
params ["_target", "_caller", "_id", "_arguments"];
private _traumaStart = _target getVariable "DPCS_SYSMED_TRAUMA_START"; // 5
private _traumaTime = time - _traumaStart; // 15 - 5 = 10
private _traumaTimeLeft = (DPCS_SYSMED_REVIVE_TIME_LIMIT - _traumaTime) max 0;

// Format time with leading zeros
private _minutes = floor(_traumaTimeLeft / 60); // 205 / 60 = 3
private _seconds = floor(_traumaTimeLeft % 60); // 205 % 60 = 25
private _timeStr = format ["%1:%2", _minutes,_seconds]; // 3:25

// Find nearest medical vehicle/facility
private _nearestMedical = trauma_unit;
private _medicalDist = if (!isNull _nearestMedical) then {
    round(_target distance _nearestMedical)
} else {
    "NO MEDICAL FACILITY NEARBY"
};

hint parseText format [
    "<t size='1.2' color='#ff0000'>URGENT CASUALTY STATUS</t><br/><br/>" +
    "Time Until Critical: %1<br/>" +
    "Distance to FOB: %2m<br/>" +
    "Status: URGENT - Immediate CASEVAC Required",
    _timeStr,
    _medicalDist
];

================
File: functions/medical/fn_handleUnitDeath.sqf
================
// File: functions\medical\fn_handleUnitDeath.sqf
params ["_unit"];

_reviveTimeLimit = DPCS_SYSMED_REVIVE_TIME_LIMIT;

if (!isPlayer _unit) then {
    // Create radio message based on unit's role and squad
    private _radioMsg = format [
        "Fuck I'm hit!", 
        "ACTUAL"];
    
    // Send radio message using the reporter
    [_unit, _radioMsg] spawn {
        params ["_speaker", "_msg"];
        _speaker sideChat _msg;
    };
    
    // Optional: Add visual radio effect
    private _reporterPos = getPosATL _unit;
    private _radioObj = "Land_HelipadEmpty_F" createVehicle _reporterPos;
    _radioObj say3D ["radioreport", 100];  // You'll need to define this sound
    deleteVehicle _radioObj;

    _unit setVariable ["DPCS_SYSMED_TRAUMA_START", time]; // 5
    _unit allowDamage false;
    _unit setUnconscious true;
    _unit disableAI "ALL";
    _unit enableAI "ANIM";

    DPCS_SYSMED_TRAUMA_UNITS pushBack _unit;

    // add action to view trauma status
    _unit addAction [
        "<t color='#ff0000'>Check URGENT Casualty</t>",
        DPC_fnc_checkUnitTraumaStatus,
        nil,
        10,
        false,
        true,
        "",
        "_this distance _target < 2"
    ];
    [_unit, DPCS_SYSMED_REVIVE_TIME_LIMIT] spawn {
        params ["_unit", "_reviveTimeLimit"];
        [_unit, _reviveTimeLimit] call DPC_fnc_addUnitTraumaStatus;
    };
};

================
File: functions/medical/fn_initMedicalSystems.sqf
================
// File: functions\medical\fn_initMedicalSystem.sqf
private _isEnabled = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "ENABLED");
private _isDebug = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "DEBUG");
private _isMedicalEnabled = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "DPCS_MEDICAL");
if(_isEnabled == 1 && _isMedicalEnabled == 1) then {
    // Initialize medical system constants
    DPCS_SYSMED_TRAUMA_UNITS = [];
    DPCS_SYSMED_MEDICAL_FACILITIES = [trauma_unit];
    DPCS_SYSMED_REVIVE_TIME_LIMIT = 600;    
    DPCS_SYSMED_REVIVE_TIME = 60;
    DPCS_SYSMED_MAX_REVIVE_DISTANCE = 20;
    DPCS_SYSMED_SKILL_PENALTY = 0.1;
    DPCS_SYSMED_MAX_CASEVAC_DISTANCE = 15;
    DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY = 2;
    DPCS_SYSMED_ACTIVE_TREATMENTS = 0;

    { 
        publicVariable _x 
    } forEach [
        "DPCS_SYSMED_TRAUMA_UNITS",
        "DPCS_SYSMED_MEDICAL_FACILITIES",
        "DPCS_SYSMED_REVIVE_TIME_LIMIT",
        "DPCS_SYSMED_REVIVE_TIME",
        "DPCS_SYSMED_MAX_REVIVE_DISTANCE",
        "DPCS_SYSMED_SKILL_PENALTY",
        "DPCS_SYSMED_MAX_CASEVAC_DISTANCE",
        "DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY",
        "DPCS_SYSMED_ACTIVE_TREATMENTS"
        ];

    [] call DPC_fnc_addDeathHandler;
    [] call DPC_fnc_addLoadAction;
    { 
    [_x] call DPC_fnc_addReviveAction;    
    } forEach DPCS_SYSMED_MEDICAL_FACILITIES;
    [] call DPC_fnc_startSurgeryAmbientAnim;
};

if(_isDebug == 1) then {
    systemChat "Medical system initialized";

    player addAction [
        "Debug: Add Casualty",
        {
           // log all allVariables
            private _text = "";

            private _varNames = [
                "TRAUMA_UNITS: ",
                "MEDICAL_FACILITIES: ",
                "REVIVE_TIME_LIMIT: ",
                "REVIVE_TIME: ",
                "MAX_REVIVE_DISTANCE: ",
                "SKILL_PENALTY: ",
                "MAX_CASEVAC_DISTANCE: ",
                "MAX_MEDICAL_FACILITY_CAPACITY: ",
                "ACTIVE_TREATMENTS: "
            ];

            private _vars = [
                DPCS_SYSMED_TRAUMA_UNITS,
                DPCS_SYSMED_MEDICAL_FACILITIES,
                DPCS_SYSMED_REVIVE_TIME_LIMIT,
                DPCS_SYSMED_REVIVE_TIME,
                DPCS_SYSMED_MAX_REVIVE_DISTANCE,
                DPCS_SYSMED_SKILL_PENALTY,
                DPCS_SYSMED_MAX_CASEVAC_DISTANCE,
                DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY,
                DPCS_SYSMED_ACTIVE_TREATMENTS
            ];

            {
                _text = _text + format ["%1%2\n", _varNames select _forEachIndex, _x];
            } forEach _vars;

            copyToClipboard _text;
            systemChat "Debug: All Medical variables copied to clipboard";
        }
    ];
};

================
File: functions/medical/fn_loadCasualtyAction.sqf
================
params ["_vehicle", "_caller", "_actionId", "_deadUnit"];

private _traumaUnits = DPCS_SYSMED_TRAUMA_UNITS;
private _nearestDead = objNull;

if (isNil "_traumaUnits" || {count _traumaUnits == 0}) exitWith {
    systemChat "No casualties to load";
};

if (_vehicle emptyPositions "cargo" == 0) exitWith {
    systemChat "Vehicle cargo is full!";
};

{
    if (_x distance _vehicle < DPCS_SYSMED_MAX_CASEVAC_DISTANCE && 
        {!(_x in (crew _vehicle))} &&
        {isNil { _x  getVariable "DPCS_SYSMED_REVIVE_PROGRESS"}} &&
        {_x getVariable ["DPCS_SYSMED_TRAUMA_START", -1] != -1}) exitWith {
        _nearestDead = _x;
    };
} forEach _traumaUnits;

if (!isNull _nearestDead) then {
    _nearestDead moveInCargo _vehicle;
    _nearestDead switchMove "KIA_passenger_boat_holdleft";
    _cargoIndex = _vehicle getCargoIndex _nearestDead;
    _vehicle lockCargo [_cargoIndex, true];
    [_nearestDead] call DPC_fnc_addUnloadBodyAction;
    
    systemChat format ["Vehicle now has %1 passenger seats remaining", 
        (_vehicle emptyPositions "cargo")];
    
    if (_vehicle emptyPositions "cargo" == 0) then {
        _vehicle removeAction _actionId;
    };
};

================
File: functions/medical/fn_startSurgeryAmbientAnim.sqf
================
// Start the monitoring loop
[] spawn {
private _lastState = 1;  // Initialize to invalid state to force first update

while {true} do {
    // Check if state has changed
    if (DPCS_SYSMED_ACTIVE_TREATMENTS > 0 && _lastState <= 0) then {
        // Activate animations
        surgeon switchMove "AinvPknlMstpSnonWnonDr_medic0";
        patient switchMove "ainjppnemstpsnonwnondnon_rolltoback";
        
        {
            _x disableAI "ALL";
            _x enableSimulation true;
            _x hideObject false;
        } forEach [surgeon, patient];
        
        _lastState = 1;
    };
    
    if (DPCS_SYSMED_ACTIVE_TREATMENTS <= 0 && _lastState > 0) then {
        // Deactivate animations
        {
            _x disableAI "ALL";
            _x enableSimulation false;
            _x hideObject true;
        } forEach [surgeon, patient];
        
        _lastState = 0;
    };
    
    sleep 1;  // Check every half second
};
};

================
File: functions/supply/fn_addPlatoonGear.sqf
================
/*
Structure:
- HQ Element (4): PL, PSG, RTO, Medic
- 3x Infantry Squads (9 each): SL, 2x Fire Teams (TL, AR, GR, R)
- Weapons Squad (8): SL, 2x MG Teams (Team Leader, Gunner, Assistant Gunner, Ammo Bearer)
Total: 39 personnel
*/


params [["_box", objNull, [objNull]]];

if (isNull _box) exitWith {
    diag_log "[DPC] Error: Null box passed to addPlatoonGear";
};

// Clear existing cargo
clearWeaponCargoGlobal _box;
clearMagazineCargoGlobal _box;
clearItemCargoGlobal _box;
clearBackpackCargoGlobal _box;

// Weapons
private _rifleCount = 25;         // Standard riflemen
private _glCount = 6;             // Grenadiers (2 per squad)
private _arCount = 6;             // Auto Riflemen (2 per squad)
private _mgCount = 4;             // Machine Gunners (2 teams in weapons squad)
private _tlRifleCount = 8;        // TL rifles (modified with better optics)
private _pistolCount = 8;         // Officers and senior NCOs

// Basic Rifles and Ammo
_box addWeaponCargoGlobal ["arifle_MX_F", _rifleCount];
_box addMagazineCargoGlobal ["30Rnd_65x39_caseless_mag", _rifleCount * 10];

// Team Leader Rifles
_box addWeaponCargoGlobal ["arifle_MX_Black_F", _tlRifleCount];
_box addMagazineCargoGlobal ["30Rnd_65x39_caseless_black_mag", _tlRifleCount * 10];

// Grenadier Weapons and Ammo
_box addWeaponCargoGlobal ["arifle_MX_GL_F", _glCount];
_box addMagazineCargoGlobal ["1Rnd_HE_Grenade_shell", _glCount * 12];
_box addMagazineCargoGlobal ["1Rnd_Smoke_Grenade_shell", _glCount * 4];
_box addMagazineCargoGlobal ["1Rnd_SmokeRed_Grenade_shell", _glCount * 2];
_box addMagazineCargoGlobal ["1Rnd_SmokeGreen_Grenade_shell", _glCount * 2];
_box addMagazineCargoGlobal ["UGL_FlareWhite_F", _glCount * 4];

// Auto Rifles and Ammo
_box addWeaponCargoGlobal ["arifle_MX_SW_F", _arCount];
_box addMagazineCargoGlobal ["100Rnd_65x39_caseless_mag", _arCount * 6];
_box addItemCargoGlobal ["bipod_01_F_blk", _arCount];

// Machine Guns and Ammo
_box addWeaponCargoGlobal ["MMG_02_black_F", _mgCount];
_box addMagazineCargoGlobal ["130Rnd_338_Mag", _mgCount * 8];

// Pistols for Officers/NCOs
_box addWeaponCargoGlobal ["hgun_P07_F", _pistolCount];
_box addMagazineCargoGlobal ["16Rnd_9x21_Mag", _pistolCount * 3];

// Launchers
_box addWeaponCargoGlobal ["launch_NLAW_F", 6];         // 2 per squad
_box addWeaponCargoGlobal ["launch_MRAWS_green_F", 2];  // Weapons squad
_box addMagazineCargoGlobal ["MRAWS_HEAT_F", 8];

// Grenades and Explosives
_box addMagazineCargoGlobal ["HandGrenade", 80];        // ~2 per person
_box addMagazineCargoGlobal ["SmokeShell", 80];         // ~2 per person
_box addMagazineCargoGlobal ["SmokeShellRed", 12];
_box addMagazineCargoGlobal ["SmokeShellGreen", 12];
_box addMagazineCargoGlobal ["DemoCharge_Remote_Mag", 4];
_box addItemCargoGlobal ["ACE_M26_Clacker", 2];

// Medical Supplies
_box addItemCargoGlobal ["Medikit", 4];                 // Medics
_box addItemCargoGlobal ["FirstAidKit", 40];            // 1 per person + extra

// Equipment
_box addItemCargoGlobal ["Binocular", 12];              // Leaders
_box addItemCargoGlobal ["Rangefinder", 2];             // PL and PSG
_box addItemCargoGlobal ["ItemGPS", 12];                // Leaders
_box addItemCargoGlobal ["B_UavTerminal", 1];           // PL

// Radios (if TFAR is used)
_box addBackpackCargoGlobal ["B_RadioBag_01_mtp_F", 2];     // Long range
_box addItemCargoGlobal ["ItemRadio", 39];                   // Short range

// Additional Items
_box addItemCargoGlobal ["acc_pointer_IR", 39];             // 1 per person
_box addItemCargoGlobal ["optic_Hamr", 20];                 // For key positions
_box addItemCargoGlobal ["optic_MRCO", 20];                 // Alternative optic
_box addItemCargoGlobal ["NVGoggles", 39];                  // 1 per person
_box addItemCargoGlobal ["ItemCompass", 39];                // 1 per person
_box addItemCargoGlobal ["ItemMap", 39];                    // 1 per person
_box addItemCargoGlobal ["ItemWatch", 39];                  // 1 per person
_box addItemCargoGlobal ["ToolKit", 2];                     // For repairs

// Set cargo space
[_box, 2000] remoteExecCall ["setMaxLoad", 0, _box];


/*
Example usage:
[_box] call DPC_fnc_addPlatoonGear;
*/

================
File: functions/supply/fn_requestVehicle.sqf
================
// Example usage
private _startPos = [14733.6,16677.4,0];    // Where to spawn the heli (with attached vehicle)
private _dropPos = [21618.4,15277.2,0];     // Where to drop the vehicle
private _basePos = _startPos;       // Where the helicopter should return to
private _vehicleClass = "B_MRAP_01_F";
private _heliClass = "B_Heli_Transport_03_F";

[_startPos, _dropPos, _vehicleClass, _heliClass, _basePos] call DPC_fnc_slingLoadVehicle;

================
File: functions/supply/fn_turretsSupply.sqf
================
params [["_box", objNull, [objNull]]];

if (isNull _box) exitWith {
    diag_log "[DPC] Error: Null box passed to addStaticsToBox";
};

// Clear existing cargo
clearWeaponCargoGlobal _box;
clearMagazineCargoGlobal _box;
clearItemCargoGlobal _box;
clearBackpackCargoGlobal _box;

// Static weapon classnames
private _hmgBackpacks = [
    "B_HMG_01_high_weapon_F", 
    "B_HMG_01_support_high_F"
];
private _gmgBackpacks = [
    "B_GMG_01_high_weapon_F",
    "B_HMG_01_support_high_F"
];
private _atBackpacks = [
    "B_AT_01_weapon_F",
    "B_HMG_01_support_F"
];

// Add HMG turrets (8 sets)
{
    _box addBackpackCargoGlobal [_x, 8];
} forEach _hmgBackpacks;

// Add GMG turrets (6 sets)
{
    _box addBackpackCargoGlobal [_x, 6];
} forEach _gmgBackpacks;

// Add AT turrets (6 sets)
{
    _box addBackpackCargoGlobal [_x, 6];
} forEach _atBackpacks;

// Set cargo space
[_box, 30] remoteExecCall ["setMaxLoad", 0, _box];

================
File: functions/util/fn_addStaticManipulation.sqf
================
params ["_static"];

_static addAction [
"Carry Weapon",
{
    params ["_static", "_player"];
    [_static, _player] spawn DPC_fnc_carryStatic;
}, 
nil, 
4, 
true, 
true, 
"",
"isNull attachedTo _target && {isNull objectParent _this} && {!(_this getVariable ['DPC_carryingStatic', false])} && {count crew _target == 0}", 
3
];

================
File: functions/util/fn_adjustStaticHeight.sqf
================
params ["_player"];

private _static = _player getVariable ["DPC_staticCarried", objNull];
if (isNull _static) exitWith {};

private _currentHeight = _player getVariable ["DPC_heightOffset", 1];
private _newHeight = _currentHeight + 1;
if (_newHeight > 5) then {_newHeight = 1};

_player setVariable ["DPC_heightOffset", _newHeight];

private _bbr = boundingBoxReal _static;
private _p1 = _bbr select 0;
private _p2 = _bbr select 1;
private _height = abs((_p2 select 2) - (_p1 select 2)) + 0.2;

detach _static;
_static attachTo [_player, [0, 1, _newHeight]];

================
File: functions/util/fn_carryStatic.sqf
================
params ["_static", "_player"];

if (_static isKindOf "StaticWeapon" && count crew _static > 0) exitWith {};

// Lock static and disable damage
_static lock true;
_static allowDamage false;

// Set mass very low to prevent physics issues
if (isNil {_static getVariable "originalMass"}) then {
_static setVariable ["originalMass", getMass _static];
};
[_static, 1e-10] remoteExecCall ["setMass", 0];
[_static, false] remoteExecCall ["enableSimulationGlobal", 2];

// Attach static to player
private _bbr = boundingBoxReal _static;
private _p1 = _bbr select 0;
private _p2 = _bbr select 1;
private _height = abs((_p2 select 2) - (_p1 select 2)) + 0.2;

private _heightOffset = _player getVariable ["DPC_heightOffset", 1];
_static attachTo [_player, [0, 1, _heightOffset + 0.1]];

// Add prevent-vehicle eventhandler
private _ehCarry = _player addEventHandler ["GetInMan", {
    params ["_unit"];
    _unit call DPC_fnc_dropStatic;
}];

// Store variables
_player setVariable ["DPC_staticCarried", _static];
_player setVariable ["DPC_carryingStatic", true];
_player setVariable ["DPC_carryEH", _ehCarry];
_player setVariable ["DPC_heightOffset", 0];

// Add drop action
private _dropID = _player addAction [
"Drop Static",
{
    params ["_player"];
    _player call DPC_fnc_dropStatic;
},
nil,
4,
true,
true,
"",
"true"
];
_player setVariable ["DPC_dropAction", _dropID];

// Add elevation action
private _elevateID = _player addAction [
    "Adjust Height",
    {
        params ["_target", "_caller"];
        _caller call DPC_fnc_adjustStaticHeight;
    },
    nil,
    4.8,
    true,
    true,
    "",
    "true"
];
_player setVariable ["DPC_elevateAction", _elevateID];

// Monitor player state
[_player, _static] spawn {
params ["_player", "_static"];
while {_player getVariable ["DPC_carryingStatic", false]} do {
    _player allowSprint false;
    if (!alive _static || !alive _player || lifeState _player == "INCAPACITATED") exitWith {
        if (_player getVariable ["DPC_carryingStatic", false]) then {
            _player call DPC_fnc_dropStatic;
        };
    };
    sleep 0.5;
};
_player allowSprint true;
};

================
File: functions/util/fn_dropStatic.sqf
================
params ["_player"];

private _dropID = _player getVariable ["DPC_dropAction", -1];
private _static = _player getVariable ["DPC_staticCarried", objNull];
private _ehCarry = _player getVariable ["DPC_carryEH", -1];
 private _elevateID = _player getVariable ["DPC_elevateAction", -1];

if (_dropID != -1) then {_player removeAction _dropID};
if (_ehCarry != -1) then {_player removeEventHandler ["GetInMan", _ehCarry]};
if (_elevateID != -1) then {_player removeAction _elevateID};

_player setVariable ["DPC_staticCarried", nil];
_player setVariable ["DPC_carryingStatic", false];
_player setVariable ["DPC_dropAction", nil];
_player setVariable ["DPC_elevateAction", nil];
 _player setVariable ["DPC_heightOffset", nil];
_player setVariable ["DPC_carryEH", nil];

if (!isNull _static) then {
    detach _static;
    
    // Restore original mass
    private _mass = _static getVariable ["DPC_originalMass", 100];
    [_static, _mass] remoteExec ["setMass", _static];
    [_static, true] remoteExec ["enableSimulationGlobal", 2];
    
    // Place properly on ground
    private _pos = getPosATL _static;
    _static setPosATL _pos;
    _static setVectorUp surfaceNormal position _static;
    
    _static lock false;
};

================
File: functions/util/fn_isCarrying.sqf
================
params ["_player"];

// Check various carry states
if (_player getVariable ["DPC_carryingStatic", false]) exitWith { true };
falses

================
File: functions/util/fn_processAllStatics.sqf
================
// Start the continuous processing
[] spawn {
    private ["_allStatics", "_processedCount"];
    private _radius = 300;
    private _center = getMarkerPos "base";
    
    while {alive player} do {
        _allStatics = [];
        _processedCount = 0;
        
        // Search for statics in radius
        _allStatics = _center nearEntities [["StaticWeapon"], _radius];
        
        // Process found statics
        {
            if (isNull _x || {_x getVariable ["DPC_processed", false]}) then {continue};
            
            [_x] call DPC_fnc_addStaticManipulation;
            _x setVariable ["DPC_processed", true];
            _processedCount = _processedCount + 1;
            
        } forEach _allStatics;
        
        // Log only if we found new statics
        if (_processedCount > 0) then {
            systemChat format ["Processed %1 static weapons", _processedCount];
        };
        
        // Wait before next check
        sleep 10;
    };
    
    systemChat "Static weapon processing stopped - player dead";
};

================
File: functions/util/fn_slingLoadVehicle.sqf
================
/*
Author: Dylan Britz
Description:
    Creates an AI-controlled helicopter with pre-attached sling load.
    1. Spawns helicopter with vehicle already attached
    2. Moves to dropoff point
    3. Detaches load
    4. Returns to base

Arguments:
    0: <ARRAY> Start position in format [x,y,z]
    1: <ARRAY> Dropoff position in format [x,y,z]
    2: <STRING> Vehicle classname to be transported
    3: <STRING> Helicopter classname to use
    4: <ARRAY> Base position for helicopter return [x,y,z]
    5: <NUMBER> (Optional) Spawn height above start position (default: 100)

Return Value:
    <ARRAY> [_heli, _vehicle] - References to created objects

Example:
    [_startPos, _dropPos, "B_MRAP_01_F", "B_Heli_Transport_03_F", _basePos] call A3A_fnc_aiSlingLoad;
*/

params [
["_startPos", [0,0,0], [[]], [3]],
["_dropPos", [0,0,0], [[]], [3]],
["_vehicleClass", "B_MRAP_01_F", [""]],
["_heliClass", "B_Heli_Transport_03_F", [""]],
["_basePos", [0,0,0], [[]], [3]],
["_spawnHeight", 100, [0]]
];

// Create helicopter at specified height
private _spawnPos = _startPos vectorAdd [0, 0, _spawnHeight];
private _heliGroup = createGroup west;
private _heli = createVehicle [_heliClass, _spawnPos, [], 0, "FLY"];
private _pilot = _heliGroup createUnit ["B_Helipilot_F", [0,0,0], [], 0, "NONE"];
_pilot moveInDriver _heli;
_heliGroup selectLeader _pilot;

// Create vehicle slightly below helicopter
private _vehicle = createVehicle [_vehicleClass, _startPos vectorAdd [0, 0, 20], [], 0, "NONE"];
_vehicle allowDamage false; // Prevent damage during spawn
_heli setSlingLoad _vehicle;

// Wait a frame to ensure sling is properly attached
[_vehicle] spawn {
params ["_vehicle"];
sleep 0.1;
_vehicle allowDamage true;
};

// Set helicopter behavior
{_x disableAI "AUTOCOMBAT"} forEach units _heliGroup;
{_x disableAI "AUTOTARGET"} forEach units _heliGroup;
{_x disableAI "TARGET"} forEach units _heliGroup;
_heliGroup setBehaviour "CARELESS";
_heliGroup setCombatMode "BLUE";

// Function to create waypoint
private _fnc_createWP = {
    params ["_group", "_pos", "_type", "_behavior", "_speed", "_radius", "_index"];
    private _indexDefault = count waypoints _group -1;
    private _customIndex = if (isNil _index) then {_indexDefault} else {_index};
    private _wp = _group addWaypoint [_pos, 0];
    _wp setWaypointType _type;
    _wp setWaypointBehaviour _behavior;
    _wp setWaypointSpeed _speed;
    _wp setWaypointCompletionRadius _radius;
    _wp;
};

// Move to drop position
[_heliGroup, _dropPos, "MOVE", "CARELESS", "NORMAL", 5] call _fnc_createWP;
// Drop sequence
[_fnc_createWP, _heli, _dropPos, _heliGroup, _basePos] spawn {
    params ["_fnc_createWP", "_heli", "_dropPos", "_heliGroup", "_basePos"];
    waitUntil {_heli distance2D _dropPos < 150};
    sleep 1;
    [_heliGroup, _dropPos, "UNHOOK", "CARELESS", "NORMAL", 5] call _fnc_createWP;
    private _wpEnd = [_heliGroup, _basePos vectorAdd [0,0,100], "MOVE", "CARELESS", "NORMAL", 150] call _fnc_createWP;
    _wpEnd setWaypointStatements ["true", "{deleteVehicle (vehicle _x)} forEach thisList; {deleteVehicle _x} forEach thisList"];
};

[_heli, _vehicle]

================
File: initPlatoonGroups.sqf
================
// // File: functions\config\fn_initPlatoonGroups.sqf

// /*
//     Author: Your Name
//     Description: Initializes or replenishes a NATO infantry platoon
    
//     Parameters:
//         _spawnPos: Array/Object - Position to spawn units [x,y,z] or object
//         _replenish: Boolean - True to check and replenish existing groups
    
//     Returns: Array of groups created/replenished
    
//     Example:
//     [getMarkerPos "platoon_start", false] call DPC_fnc_initPlatoonGroups;
// */

// params [
//     ["_spawnPos", [0,0,0], [[],objNull]],
//     ["_replenish", false, [false]]
// ];

// // NATO Infantry unit types
// #define UNIT_OFFICER "B_officer_F"
// #define UNIT_SQL "B_Soldier_SL_F"
// #define UNIT_TL "B_Soldier_TL_F"
// #define UNIT_MEDIC "B_medic_F"
// #define UNIT_AR "B_soldier_AR_F"
// #define UNIT_GREN "B_Soldier_GL_F"
// #define UNIT_LAT "B_soldier_LAT_F"
// #define UNIT_RADIO "B_Soldier_lite_F"

// // Platoon structure definitions
// private _platoonStructure = [
//     // HQ Squad - 4 men
//     [
//         "HQ", [
//             [UNIT_OFFICER, "Platoon Commander"],
//             [UNIT_MEDIC, "Platoon Medic"],
//             [UNIT_RADIO, "Platoon RTO"],
//             [UNIT_TL, "Platoon Sergeant"]
//         ]
//     ],
//     // Three identical infantry squads - 8 men each
//     [
//         "Alpha", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Bravo", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Charlie", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ]
// ];

// // Convert spawn position
// _spawnPos = if (_spawnPos isEqualType objNull) then {
//     getPos _spawnPos
// } else {
//     _spawnPos
// };

// // Initialize platoon groups array if needed
// if (isNil "PLATOON_GROUPS" && !_replenish) then {
//     PLATOON_GROUPS = [];
// };

// // Function to create a single unit
// private _fnc_createUnit = {
//     params ["_type", "_role", "_group", "_pos"];
    
//     private _unit = _group createUnit [_type, _pos, [], 5, "NONE"];
//     _unit setRank "PRIVATE";
//     _unit setVariable ["DPC_Role", _role, true];  // Added true for global broadcast
    
//     // Set ranks based on role
//     switch (toLower _role) do {
//         case "platoon commander": { _unit setRank "LIEUTENANT" };
//         case "platoon sergeant": { _unit setRank "SERGEANT" };
//         case "squad leader": { _unit setRank "SERGEANT" };
//         case "team leader": { _unit setRank "CORPORAL" };
//         default { _unit setRank "PRIVATE" };
//     };
    
//     _unit
// };

// // Process each squad in the platoon structure
// {
//     _x params ["_squadName", "_composition"];
//     private "_group";
    
//     // Check if group exists when replenishing
//     if (_replenish) then {
//         {
//             if ((_x getVariable ["DPC_SquadName", ""]) == _squadName) exitWith {
//                 _group = _x;
//             };
//         } forEach PLATOON_GROUPS;
//     };
    
//     // Create new group if needed
//     if (isNil "_group" || {isNull _group}) then {
//         _group = createGroup [west, true];
//         _group setVariable ["DPC_SquadName", _squadName, true];  // Added true for global broadcast
//         PLATOON_GROUPS pushBack _group;
//     };
    
//     // Create or replenish units
//     {
//         _x params ["_type", "_role"];
        
//         // Check if we need this role when replenishing
//         private _needUnit = true;
//         if (_replenish) then {
//             {
//                 if (alive _x && {_x getVariable ["DPC_Role", ""] == _role}) exitWith {
//                     _needUnit = false;
//                 };
//             } forEach (units _group);
//         };
        
//         // Create unit if needed
//         if (_needUnit) then {
//             [_type, _role, _group, _spawnPos] call _fnc_createUnit;
//         };
//     } forEach _composition;
    
//     // Basic group settings
//     _group enableDynamicSimulation true;
//     _group setFormation "WEDGE";
    
// } forEach _platoonStructure;

// // Return the groups array
// PLATOON_GROUPS

================
File: ui/controls.hpp
================
// File: ui/controls.hpp
class RscText {
    type = 0;
    idc = -1;
    style = 0;
    colorBackground[] = {0,0,0,0};
    colorText[] = {1,1,1,1};
    font = "RobotoCondensed";
    sizeEx = 0.032;
    h = 0.05;
    text = "";
};

class RscButton {
    type = 1;
    style = 2;
    x = 0;
    y = 0;
    w = 0.095589;
    h = 0.039216;
    shadow = 2;
    font = "RobotoCondensed";
    sizeEx = 0.032;
    colorText[] = {1,1,1,1};
    colorDisabled[] = {0.4,0.4,0.4,1};
    colorBackground[] = {0.4,0.4,0.4,1};
    colorBackgroundDisabled[] = {0.3,0.3,0.3,1};
    colorBackgroundActive[] = {0.5,0.5,0.5,1};
    offsetX = 0.003;
    offsetY = 0.003;
    offsetPressedX = 0.002;
    offsetPressedY = 0.002;
    colorFocused[] = {0.5,0.5,0.5,1};
    colorShadow[] = {0,0,0,1};
    colorBorder[] = {0,0,0,1};
    borderSize = 0.0;
    soundEnter[] = {"\A3\ui_f\data\sound\RscButton\soundEnter",0.09,1};
    soundPush[] = {"\A3\ui_f\data\sound\RscButton\soundPush",0.09,1};
    soundClick[] = {"\A3\ui_f\data\sound\RscButton\soundClick",0.09,1};
    soundEscape[] = {"\A3\ui_f\data\sound\RscButton\soundEscape",0.09,1};
};

class RscListBox {
    type = 5;
    style = 16;
    font = "RobotoCondensed";
    sizeEx = 0.032;
    rowHeight = 0.03;
    colorText[] = {1,1,1,1};
    colorDisabled[] = {1,1,1,0.25};
    colorScrollbar[] = {1,0,0,0};
    colorSelect[] = {0,0,0,1};
    colorSelect2[] = {0,0,0,1};
    colorSelectBackground[] = {0.95,0.95,0.95,1};
    colorSelectBackground2[] = {1,1,1,0.5};
    colorBackground[] = {0,0,0,0.3};
    maxHistoryDelay = 1;
    soundSelect[] = {"",0.1,1};
    period = 1;
    autoScrollSpeed = -1;
    autoScrollDelay = 5;
    autoScrollRewind = 0;
    arrowEmpty = "#(argb,8,8,3)color(1,1,1,1)";
    arrowFull = "#(argb,8,8,3)color(1,1,1,1)";
    shadow = 0;
    class ListScrollBar {
        color[] = {1,1,1,0.6};
        colorActive[] = {1,1,1,1};
        colorDisabled[] = {1,1,1,0.3};
        thumb = "#(argb,8,8,3)color(1,1,1,1)";
        arrowEmpty = "#(argb,8,8,3)color(1,1,1,1)";
        arrowFull = "#(argb,8,8,3)color(1,1,1,1)";
        border = "#(argb,8,8,3)color(1,1,1,1)";
    };
};

class RscEdit {
    type = 2;
    style = 0x00 + 0x40;
    font = "RobotoCondensed";
    shadow = 2;
    sizeEx = 0.032;
    colorBackground[] = {0,0,0,0.3};
    colorText[] = {1,1,1,1};
    colorDisabled[] = {1,1,1,0.25};
    colorSelection[] = {0,0,0,0.25};
    autocomplete = "";
    text = "";
    size = 0.2;
    canModify = 1;
};

================
File: ui/dialogs/artillery_dialog.hpp
================
// File: ui/dialogs/artillery_dialog.hpp
#include "..\controls.hpp"

class DPC_Artillery_Dialog {
    idd = 9000;
    movingEnable = true;
    
    class Controls {
        class Background: RscText {
            idc = -1;
            x = 0.3 * safezoneW + safezoneX;
            y = 0.25 * safezoneH + safezoneY;
            w = 0.4 * safezoneW;
            h = 0.5 * safezoneH;
            colorBackground[] = {0,0,0,0.8};
        };
        
        class Title: RscText {
            idc = -1;
            text = "Artillery Support";
            x = 0.3 * safezoneW + safezoneX;
            y = 0.25 * safezoneH + safezoneY;
            w = 0.4 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            style = ST_CENTER;
        };
        
        class AmmoList: RscListBox {
            idc = 9001;
            x = 0.31 * safezoneW + safezoneX;
            y = 0.31 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.35 * safezoneH;
            onLBSelChanged = "_this call DPC_fnc_onAmmoSelect;";
        };
        
        class SelectTargetBtn: RscButton {
            idc = 9002;
            text = "SELECT TARGET";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.35 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            onButtonClick = "[] call DPC_fnc_openMapForTarget;";
        };

        class SelectedTargetText: RscText {
            idc = 9005;
            text = "Grid: N/A";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.4 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
        };
        
        class RoundsLabel: RscText {
            idc = -1;
            text = "Number of Rounds:";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.48 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
        };
        
        class RoundsInput: RscEdit {
            idc = 9003;
            x = 0.47 * safezoneW + safezoneX;
            y = 0.52 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
            text = "1";
        };
        
        class FireButton: RscButton {
            idc = 9004;
            text = "REQUEST FIRE";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.6 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            onButtonClick = "_this call DPC_fnc_requestArtilleryFire;";
        };
        
        class CloseButton: RscButton {
            idc = -1;
            text = "CLOSE";
            x = 0.31 * safezoneW + safezoneX;
            y = 0.6 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            onButtonClick = "closeDialog 0;";
        };
    };
};
