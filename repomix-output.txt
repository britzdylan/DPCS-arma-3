This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-15T14:44:29.154Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
description.ext
functions/medical/fn_addDeathHandler.sqf
functions/medical/fn_addLoadAction.sqf
functions/medical/fn_addLoadBodyAction.sqf
functions/medical/fn_addReviveAction.sqf
functions/medical/fn_addUnitTraumaStatus.sqf
functions/medical/fn_addUnloadBodyAction.sqf
functions/medical/fn_checkUnitTraumaStatus.sqf
functions/medical/fn_handleUnitDeath.sqf
functions/medical/fn_initMedicalSystems.sqf
functions/medical/fn_loadCasualtyAction.sqf
functions/medical/fn_startSurgeryAmbientAnim.sqf
initPlatoonGroups.sqf

================================================================
Files
================================================================

================
File: description.ext
================
// Import base UI classes
#include "\a3\ui_f\hpp\defineCommonGrids.inc"
#include "\a3\ui_f\hpp\defineCommonColors.inc"

// Base classes needed for dialog
class RscText {
    type = 0;
    idc = -1;
    style = 0;
    colorBackground[] = {0,0,0,0};
    colorText[] = {1,1,1,1};
    font = "RobotoCondensed";
    sizeEx = 0.032;
    h = 0.05;
    text = "";
};

class RscButton {
    type = 1;
    style = 2;
    x = 0;
    y = 0;
    w = 0.095589;
    h = 0.039216;
    shadow = 2;
    font = "RobotoCondensed";
    sizeEx = 0.032;
    colorText[] = {1,1,1,1};
    colorDisabled[] = {0.4,0.4,0.4,1};
    colorBackground[] = {0.4,0.4,0.4,1};
    colorBackgroundDisabled[] = {0.3,0.3,0.3,1};
    colorBackgroundActive[] = {0.5,0.5,0.5,1};
    offsetX = 0.003;
    offsetY = 0.003;
    offsetPressedX = 0.002;
    offsetPressedY = 0.002;
    colorFocused[] = {0.5,0.5,0.5,1};
    colorShadow[] = {0,0,0,1};
    colorBorder[] = {0,0,0,1};
    borderSize = 0.0;
    soundEnter[] = {"\A3\ui_f\data\sound\RscButton\soundEnter",0.09,1};
    soundPush[] = {"\A3\ui_f\data\sound\RscButton\soundPush",0.09,1};
    soundClick[] = {"\A3\ui_f\data\sound\RscButton\soundClick",0.09,1};
    soundEscape[] = {"\A3\ui_f\data\sound\RscButton\soundEscape",0.09,1};
};

class RscListBox {
    type = 5;
    style = 16;
    font = "RobotoCondensed";
    sizeEx = 0.032;
    rowHeight = 0.03;
    colorText[] = {1,1,1,1};
    colorDisabled[] = {1,1,1,0.25};
    colorScrollbar[] = {1,0,0,0};
    colorSelect[] = {0,0,0,1};
    colorSelect2[] = {0,0,0,1};
    colorSelectBackground[] = {0.95,0.95,0.95,1};
    colorSelectBackground2[] = {1,1,1,0.5};
    colorBackground[] = {0,0,0,0.3};
    maxHistoryDelay = 1;
    soundSelect[] = {"",0.1,1};
    period = 1;
    autoScrollSpeed = -1;
    autoScrollDelay = 5;
    autoScrollRewind = 0;
    arrowEmpty = "#(argb,8,8,3)color(1,1,1,1)";
    arrowFull = "#(argb,8,8,3)color(1,1,1,1)";
    shadow = 0;
    class ListScrollBar {
        color[] = {1,1,1,0.6};
        colorActive[] = {1,1,1,1};
        colorDisabled[] = {1,1,1,0.3};
        thumb = "#(argb,8,8,3)color(1,1,1,1)";
        arrowEmpty = "#(argb,8,8,3)color(1,1,1,1)";
        arrowFull = "#(argb,8,8,3)color(1,1,1,1)";
        border = "#(argb,8,8,3)color(1,1,1,1)";
    };
};

class RscEdit {
    type = 2;
    style = 0x00 + 0x40;
    font = "RobotoCondensed";
    shadow = 2;
    sizeEx = 0.032;
    colorBackground[] = {0,0,0,0.3};
    colorText[] = {1,1,1,1};
    colorDisabled[] = {1,1,1,0.25};
    colorSelection[] = {0,0,0,0.25};
    autocomplete = "";
    text = "";
    size = 0.2;
    canModify = 1;
};

class CfgConstants 
{
    // General Mission Settings
    class DPCS_CONFIG {
        MISSION_NAME = "DPCS: Dynamic Platoon Command System";
        MISSION_AUTHOR = "Dylan Britz";
        ENABLED = 1; // Enable the DPCS system
        DEBUG = 1; // Enable debug mode
        DPCS_MEDICAL = 1; // Enable the medical system
        DPCS_FIRE_SUPPORT = 1; // Enable the fire support system
        DPCS_SUPPLY = 1; // Enable the supply system
        DPCS_TRANSPORT = 1; // Enable the transport system
    }

    // Resupply unit constants
    class SupplyPool {
        TRACKED_VEHICLE_POOL = 1;
        MRAP_VEHICLE_POOL = 15;
        HMG_VEHICLE_POOL = 10;
        GMG_VEHICLE_POOL = 7;
        QUAD_POOL = 20;
        AMMO_TRUCK_POOL = 25;
        MED_TRUCK_POOL = 5;
        REPAIR_TRUCK_POOL = 5;
        FUEL_TRUCK_POOL = 12;
        HMG_TURRET_POOL = 55;
        GMG_TURRET_POOL = 25;
        AT_TURRET_POOL = 15;
        MORTAR_TURRET_POOL = 15;
    };
};

class CfgFunctions
{
    class DPC
    {
        tag = "DPC";
        
        class Medical
        {
            file = "functions\medical";
            class addDeathHandler {};
            class addLoadAction {};
            class addLoadBodyAction {};
            class addReviveAction {};
            class addUnitTraumaStatus {};
            class addUnloadBodyAction {};
            class checkUnitTraumaStatus {};
            class handleUnitDeath {};
            class initMedicalSystems {
                postInit = 1;
            };
            class loadCasualtyAction {};
            class startSurgeryAmbientAnim {};
        };

        // class FireSupport 
        // {
        //     file = "functions\fire_support";
        //     class initArtillerySystem {
        //         postInit = 1;
        //     };
        //     class openArtilleryMenu {};
        //     class updateArtilleryAmmoUI {};
        //     class getArtilleryAmmo {};
        //     class onAmmoSelect {};
        //     class openMapForTarget {};
        // };
    };
};

class DPC_Artillery_Dialog {
    idd = 9000;  // Unique dialog ID
    movingEnable = true;  // Can be moved with mouse
    
    class Controls {
        ////////////////////////////////////////////////////////
        // Background
        ////////////////////////////////////////////////////////
        class Background: RscText {
            idc = -1;
            x = 0.3 * safezoneW + safezoneX;
            y = 0.25 * safezoneH + safezoneY;
            w = 0.4 * safezoneW;
            h = 0.5 * safezoneH;
            colorBackground[] = {0,0,0,0.8};
        };
        
        ////////////////////////////////////////////////////////
        // Title
        ////////////////////////////////////////////////////////
        class Title: RscText {
            idc = -1;
            text = "Artillery Support"; 
            x = 0.3 * safezoneW + safezoneX;
            y = 0.25 * safezoneH + safezoneY;
            w = 0.4 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            style = ST_CENTER;
        };
        
        ////////////////////////////////////////////////////////
        // Ammo List
        ////////////////////////////////////////////////////////
        class AmmoList: RscListBox {
            idc = 9001;
            x = 0.31 * safezoneW + safezoneX;
            y = 0.31 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.35 * safezoneH;
            
            // Event handler for selection change
            onLBSelChanged = "_this call DPC_fnc_onAmmoSelect;";
        };
        
        ////////////////////////////////////////////////////////
        // Grid Input
        ////////////////////////////////////////////////////////
        class SelectTargetBtn: RscButton {
            idc = 9002;
            text = "SELECT TARGET";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.35 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            onButtonClick = "[] call DPC_fnc_openMapForTarget;";
        };

         class SelectedTargetText: RscText {
            idc = 9005;
            text = "Grid: N/A";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.4 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
        };
        
        ////////////////////////////////////////////////////////
        // Rounds Input
        ////////////////////////////////////////////////////////
        class RoundsLabel: RscText {
            idc = -1;
            text = "Number of Rounds:";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.48 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
        };
        
        class RoundsInput: RscEdit {
            idc = 9003;
            x = 0.47 * safezoneW + safezoneX;
            y = 0.52 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.03 * safezoneH;
            text = "1";
        };
        
        ////////////////////////////////////////////////////////
        // Buttons
        ////////////////////////////////////////////////////////
        class FireButton: RscButton {
            idc = 9004;
            text = "REQUEST FIRE";
            x = 0.47 * safezoneW + safezoneX;
            y = 0.6 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            colorBackground[] = {0.4,0,0,1};
            
            // Event handler for button click
            onButtonClick = "_this call DPC_fnc_requestArtilleryFire;"; // TODO: Implement this function
        };
        
        class CloseButton: RscButton {
            idc = -1;
            text = "CLOSE";
            x = 0.31 * safezoneW + safezoneX;
            y = 0.6 * safezoneH + safezoneY;
            w = 0.15 * safezoneW;
            h = 0.04 * safezoneH;
            
            // Event handler for button click
            onButtonClick = "closeDialog 0;";
        };
    };
};

================
File: functions/medical/fn_addDeathHandler.sqf
================
// Add death handlers to all existing units on the players side

private _eligibleUnits = allUnits select {
    private _isValidUnit = 
        alive _x && 
        {!isPlayer _x} && 
        {side _x == playerSide} && 
        {!(_x getVariable ["DPC_SYSMED_EXCLUDE", false])} &&
        {isNil {_x getVariable "DPC_SYSMED_TRAUMA_HANDLER"}};

    if (!_isValidUnit) then {
        diag_log format ["[DPC: SYSMED] Warning: Invalid unit found: %1", _x];
    };

    _isValidUnit
};

{
    private _handlerId = _x addEventHandler ["HandleDamage", {
            params ["_unit", "_selection", "_damage"];
                if (_damage >= 0.9) then {
                    [_unit] call DPC_fnc_handleUnitDeath;
                };
        }];
    _x setVariable ["DPC_SYSMED_TRAUMA_HANDLER", _handlerId];
} forEach _eligibleUnits;

================
File: functions/medical/fn_addLoadAction.sqf
================
// Add load actions to appropriate vehicles
{
    if (_x isKindOf "Car" || _x isKindOf "Tank" || _x isKindOf "Air") then {
        [_x] call DPC_fnc_addLoadBodyAction;
    };
} forEach vehicles;

================
File: functions/medical/fn_addLoadBodyAction.sqf
================
// File: functions\medical\fn_addLoadBodyAction.sqf
params ["_vehicle"];
private _conditionStr = "
private _nearbyUnits = nearestObjects [_target, ['Man'], DPCS_SYSMED_MAX_CASEVAC_DISTANCE];
private _loadableCasualties = count (_nearbyUnits select {
    _x in DPCS_SYSMED_TRAUMA_UNITS && 
    !(_x in (crew _target))
}) > 0;
_loadableCasualties && {_target emptyPositions 'cargo' > 0}
";

_vehicle addAction [
    "Load Casualty",
    DPC_fnc_loadCasualtyAction,
    nil,
    1.5,
    true,
    true,
    "",
    _conditionStr
];

================
File: functions/medical/fn_addReviveAction.sqf
================
// File: functions\medical\fn_addReviveAction.sqf
params ["_building"];

_building addAction [
    "Begin Medical Treatment",
    {
        params ["_building", "_caller", "_actionId"];
        
        // Count current treatments
        private _currentTreatments = count ((nearestObjects [_building, ["Man"], DPCS_SYSMED_MAX_REVIVE_DISTANCE]) select {
            !isNil {_x getVariable "DPCS_SYSMED_REVIVE_PROGRESS"}
        });
        
        // Get all dead units near building not already being treated
        private _nearbyDead = (nearestObjects [_building, ["Man"], DPCS_SYSMED_MAX_REVIVE_DISTANCE]) select {
            _x in (DPCS_SYSMED_TRAUMA_UNITS) &&
            isNil {_x getVariable "DPCS_SYSMED_REVIVE_PROGRESS"}
        };
        
        // Calculate how many more we can treat
        private _availableSlots = DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY - _currentTreatments;
        
        if (_availableSlots <= 0) exitWith {
            systemChat format ["Medical facility at maximum capacity (%1 patients)", DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY];
        };
        
        if (count _nearbyDead > 0) then {
            // Limit number of new treatments to available slots
            private _unitsToTreat = _nearbyDead select [0, _availableSlots];
            
            // Start revival process for each dead unit
            {
                private _deadUnit = _x;
                
                // Start revival process and pass the needed variables
                [_deadUnit, _building] spawn {
                    params ["_unit", "_building"];
                    private _startTime = time;
                    
                    // Create progress tracking variable
                    _unit hideObject true;
                    _unit enableSimulation false;
                    _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", 0, true];
                    
                    // Progress loop
                    while {time - _startTime < DPCS_SYSMED_REVIVE_TIME} do {
                        // Update progress
                        private _progress = ((time - _startTime) / DPCS_SYSMED_REVIVE_TIME) * 100;
                        _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", _progress, true];
                        
                        // Display progress for each unit
                        systemChat format ["%1 Treatment Progress: %2%3", name _unit, floor _progress, "%"];
                        sleep 5; // Update every 5 seconds
                    };

                    DPCS_SYSMED_TRAUMA_UNITS = DPCS_SYSMED_TRAUMA_UNITS - [_unit];
                    _unit setDamage 0;
                    _unit setUnconscious false;
                    _unit allowDamage true;
                    _unit switchMove ""; // Reset animation
                    _unit enableAI "ALL"; // Re-enable AI
                    _unit enableSimulation true;
                    _unit hideObject false;
                    _unit setSkill ((skill _unit) - DPCS_SYSMED_SKILL_PENALTY);
                    _unit setVariable ["DPCS_SYSMED_TRAUMA_START", nil, true];
                    systemChat format ["%1 has been revived", name _unit];
                    _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", nil, true];
                };
            } forEach _unitsToTreat;
            
            systemChat format ["Beginning treatment of %1 casualties", count _unitsToTreat];
        } else {
            systemChat "No casualties within range of medical facility";
        };
    },
    [],
    1.5,
    true,
    true,
    "",
    // Condition: Check for any nearby dead units not being treated AND facility not at capacity
    "
    private _nearbyUnits = nearestObjects [_target, ['Man'], DPCS_SYSMED_MAX_REVIVE_DISTANCE];
    private _currentTreatments = count (_nearbyUnits select {!isNil {_x getVariable 'DPCS_SYSMED_REVIVE_PROGRESS'}});
    private _hasUntreatedCasualties = count (_nearbyUnits select {
    _x in DPCS_SYSMED_TRAUMA_UNITS && 
    isNil {_x getVariable 'DPCS_SYSMED_REVIVE_PROGRESS'}
    }) > 0;
    _currentTreatments < DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY && _hasUntreatedCasualties
    "
];

================
File: functions/medical/fn_addUnitTraumaStatus.sqf
================
params ["_unit", "_reviveTimeLimit"];
private _traumaStart = _unit getVariable "DPCS_SYSMED_TRAUMA_START";

waitUntil {
    sleep 1;
    if (!isNil "_traumaStart" &&
        (time - _traumaStart >= _reviveTimeLimit)) then {
        DPCS_SYSMED_TRAUMA_UNITS = DPCS_SYSMED_TRAUMA_UNITS - [_unit];

        {_unit removeAction _x} forEach (actionIDs _unit); // Remove all actions
        _unit enableAI "ALL";
        _unit setDamage 1;
        _unit setVariable ["DPCS_SYSMED_TRAUMA_START", nil];
        _unit setVariable ["DPCS_SYSMED_REVIVE_PROGRESS", nil];
        true
    } else {
        false
    };
};

================
File: functions/medical/fn_addUnloadBodyAction.sqf
================
params ["_unit"];

_unit addEventHandler ["GetOutMan", {
    params ["_unit", "_role", "_vehicle", "_turret"];
    _vehicle lockCargo false;
}];

================
File: functions/medical/fn_checkUnitTraumaStatus.sqf
================
params ["_target", "_caller", "_id", "_arguments"];
private _traumaStart = _target getVariable "DPCS_SYSMED_TRAUMA_START"; // 5
private _traumaTime = time - _traumaStart; // 15 - 5 = 10
private _traumaTimeLeft = (DPCS_SYSMED_REVIVE_TIME_LIMIT - _traumaTime) max 0;

// Format time with leading zeros
private _minutes = floor(_traumaTimeLeft / 60); // 205 / 60 = 3
private _seconds = floor(_traumaTimeLeft % 60); // 205 % 60 = 25
private _timeStr = format ["%1:%2", _minutes,_seconds]; // 3:25

// Find nearest medical vehicle/facility
private _nearestMedical = trauma_unit;
private _medicalDist = if (!isNull _nearestMedical) then {
    round(_target distance _nearestMedical)
} else {
    "NO MEDICAL FACILITY NEARBY"
};

hint parseText format [
    "<t size='1.2' color='#ff0000'>URGENT CASUALTY STATUS</t><br/><br/>" +
    "Time Until Critical: %1<br/>" +
    "Distance to FOB: %2m<br/>" +
    "Status: URGENT - Immediate CASEVAC Required",
    _timeStr,
    _medicalDist
];

================
File: functions/medical/fn_handleUnitDeath.sqf
================
// File: functions\medical\fn_handleUnitDeath.sqf
params ["_unit"];

_reviveTimeLimit = DPCS_SYSMED_REVIVE_TIME_LIMIT;

if (!isPlayer _unit) then {
    // Create radio message based on unit's role and squad
    private _radioMsg = format [
        "Fuck I'm hit!", 
        "ACTUAL"];
    
    // Send radio message using the reporter
    [_unit, _radioMsg] spawn {
        params ["_speaker", "_msg"];
        _speaker sideChat _msg;
    };
    
    // Optional: Add visual radio effect
    private _reporterPos = getPosATL _unit;
    private _radioObj = "Land_HelipadEmpty_F" createVehicle _reporterPos;
    _radioObj say3D ["radioreport", 100];  // You'll need to define this sound
    deleteVehicle _radioObj;

    _unit setVariable ["DPCS_SYSMED_TRAUMA_START", time]; // 5
    _unit allowDamage false;
    _unit setUnconscious true;
    _unit disableAI "ALL";
    _unit enableAI "ANIM";

    DPCS_SYSMED_TRAUMA_UNITS pushBack _unit;

    // add action to view trauma status
    _unit addAction [
        "<t color='#ff0000'>Check URGENT Casualty</t>",
        DPC_fnc_checkUnitTraumaStatus,
        nil,
        10,
        false,
        true,
        "",
        "_this distance _target < 2"
    ];
    [_unit, DPCS_SYSMED_REVIVE_TIME_LIMIT] spawn {
        params ["_unit", "_reviveTimeLimit"];
        [_unit, _reviveTimeLimit] call DPC_fnc_addUnitTraumaStatus;
    };
};

================
File: functions/medical/fn_initMedicalSystems.sqf
================
// File: functions\medical\fn_initMedicalSystem.sqf
private _isEnabled = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "ENABLED");
private _isDebug = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "DEBUG");
private _isMedicalEnabled = getNumber (missionConfigFile >> "CfgConstants" >> "DPCS_CONFIG" >> "DPCS_MEDICAL");
if(_isEnabled == 1 && _isMedicalEnabled == 1) then {
    // Initialize medical system constants
    DPCS_SYSMED_TRAUMA_UNITS = [];
    DPCS_SYSMED_MEDICAL_FACILITIES = [trauma_unit];
    DPCS_SYSMED_REVIVE_TIME_LIMIT = 600;    
    DPCS_SYSMED_REVIVE_TIME = 60;
    DPCS_SYSMED_MAX_REVIVE_DISTANCE = 20;
    DPCS_SYSMED_SKILL_PENALTY = 0.1;
    DPCS_SYSMED_MAX_CASEVAC_DISTANCE = 15;
    DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY = 2;

    { 
        publicVariable _x 
    } forEach [
        "DPCS_SYSMED_TRAUMA_UNITS",
        "DPCS_SYSMED_MEDICAL_FACILITIES",
        "DPCS_SYSMED_REVIVE_TIME_LIMIT",
        "DPCS_SYSMED_REVIVE_TIME",
        "DPCS_SYSMED_MAX_REVIVE_DISTANCE",
        "DPCS_SYSMED_SKILL_PENALTY",
        "DPCS_SYSMED_MAX_CASEVAC_DISTANCE",
        "DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY"
        ];

    [] call DPC_fnc_addDeathHandler;
    [] call DPC_fnc_addLoadAction;
    { 
    [_x] call DPC_fnc_addReviveAction;    
    } forEach DPCS_SYSMED_MEDICAL_FACILITIES;
    [true] call DPC_fnc_startSurgeryAmbientAnim;
};

if(_isDebug == 1) then {
    systemChat "Medical system initialized";

    player addAction [
        "Debug: Add Casualty",
        {
           // log all allVariables
            private _text = "";

            private _varNames = [
                "TRAUMA_UNITS: ",
                "MEDICAL_FACILITIES: ",
                "REVIVE_TIME_LIMIT: ",
                "REVIVE_TIME: ",
                "MAX_REVIVE_DISTANCE: ",
                "SKILL_PENALTY: ",
                "MAX_CASEVAC_DISTANCE: ",
                "MAX_MEDICAL_FACILITY_CAPACITY: "
            ];

            private _vars = [
                DPCS_SYSMED_TRAUMA_UNITS,
                DPCS_SYSMED_MEDICAL_FACILITIES,
                DPCS_SYSMED_REVIVE_TIME_LIMIT,
                DPCS_SYSMED_REVIVE_TIME,
                DPCS_SYSMED_MAX_REVIVE_DISTANCE,
                DPCS_SYSMED_SKILL_PENALTY,
                DPCS_SYSMED_MAX_CASEVAC_DISTANCE,
                DPCS_SYSMED_MAX_MEDICAL_FACILITY_CAPACITY
            ];

            {
                _text = _text + format ["%1%2\n", _varNames select _forEachIndex, _x];
            } forEach _vars;

            copyToClipboard _text;
            systemChat "Debug: All Medical variables copied to clipboard";
        }
    ];
};

================
File: functions/medical/fn_loadCasualtyAction.sqf
================
params ["_vehicle", "_caller", "_actionId", "_deadUnit"];

private _traumaUnits = DPCS_SYSMED_TRAUMA_UNITS;
private _nearestDead = objNull;

if (isNil "_traumaUnits" || {count _traumaUnits == 0}) exitWith {
    systemChat "No casualties to load";
};

if (_vehicle emptyPositions "cargo" == 0) exitWith {
    systemChat "Vehicle cargo is full!";
};

{
    if (_x distance _vehicle < DPCS_SYSMED_MAX_CASEVAC_DISTANCE && 
        {!(_x in (crew _vehicle))} && 
        {_x getVariable ["DPCS_SYSMED_TRAUMA_START", -1] != -1}) exitWith {
        _nearestDead = _x;
    };
} forEach _traumaUnits;

if (!isNull _nearestDead) then {
    _nearestDead moveInCargo _vehicle;
    _nearestDead switchMove "KIA_passenger_boat_holdleft";
    _cargoIndex = _vehicle getCargoIndex _nearestDead;
    _vehicle lockCargo [_cargoIndex, true];
    [_nearestDead] call DPC_fnc_addUnloadBodyAction;
    
    systemChat format ["Vehicle now has %1 passenger seats remaining", 
        (_vehicle emptyPositions "cargo")];
    
    if (_vehicle emptyPositions "cargo" == 0) then {
        _vehicle removeAction _actionId;
    };
};

================
File: functions/medical/fn_startSurgeryAmbientAnim.sqf
================
params ["_show"];

surgeon hideObject true;
surgeon enableSimulation false;

patient hideObject true;
patient enableSimulation false;

surgeon disableAI "ANIM";
surgeon disableAI "MOVE";
surgeon disableAI "PATH";     
surgeon disableAI "TARGET"; 
surgeon disableAI "FSM";
surgeon switchMove "AinvPknlMstpSnonWnonDr_medic0";

patient disableAI "ANIM";      // Prevent AI from changing animations
patient disableAI "MOVE";      // Prevent AI from moving
patient disableAI "PATH";      // Prevent AI from pathfinding
patient disableAI "TARGET";    // Prevent AI from targeting
patient disableAI "FSM";       // Prevent AI behavior scriptssurgeon
patient switchMove "ainjppnemstpsnonwnondnon_rolltoback";

================
File: initPlatoonGroups.sqf
================
// // File: functions\config\fn_initPlatoonGroups.sqf

// /*
//     Author: Your Name
//     Description: Initializes or replenishes a NATO infantry platoon
    
//     Parameters:
//         _spawnPos: Array/Object - Position to spawn units [x,y,z] or object
//         _replenish: Boolean - True to check and replenish existing groups
    
//     Returns: Array of groups created/replenished
    
//     Example:
//     [getMarkerPos "platoon_start", false] call DPC_fnc_initPlatoonGroups;
// */

// params [
//     ["_spawnPos", [0,0,0], [[],objNull]],
//     ["_replenish", false, [false]]
// ];

// // NATO Infantry unit types
// #define UNIT_OFFICER "B_officer_F"
// #define UNIT_SQL "B_Soldier_SL_F"
// #define UNIT_TL "B_Soldier_TL_F"
// #define UNIT_MEDIC "B_medic_F"
// #define UNIT_AR "B_soldier_AR_F"
// #define UNIT_GREN "B_Soldier_GL_F"
// #define UNIT_LAT "B_soldier_LAT_F"
// #define UNIT_RADIO "B_Soldier_lite_F"

// // Platoon structure definitions
// private _platoonStructure = [
//     // HQ Squad - 4 men
//     [
//         "HQ", [
//             [UNIT_OFFICER, "Platoon Commander"],
//             [UNIT_MEDIC, "Platoon Medic"],
//             [UNIT_RADIO, "Platoon RTO"],
//             [UNIT_TL, "Platoon Sergeant"]
//         ]
//     ],
//     // Three identical infantry squads - 8 men each
//     [
//         "Alpha", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Bravo", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Charlie", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ]
// ];

// // Convert spawn position
// _spawnPos = if (_spawnPos isEqualType objNull) then {
//     getPos _spawnPos
// } else {
//     _spawnPos
// };

// // Initialize platoon groups array if needed
// if (isNil "PLATOON_GROUPS" && !_replenish) then {
//     PLATOON_GROUPS = [];
// };

// // Function to create a single unit
// private _fnc_createUnit = {
//     params ["_type", "_role", "_group", "_pos"];
    
//     private _unit = _group createUnit [_type, _pos, [], 5, "NONE"];
//     _unit setRank "PRIVATE";
//     _unit setVariable ["DPC_Role", _role, true];  // Added true for global broadcast
    
//     // Set ranks based on role
//     switch (toLower _role) do {
//         case "platoon commander": { _unit setRank "LIEUTENANT" };
//         case "platoon sergeant": { _unit setRank "SERGEANT" };
//         case "squad leader": { _unit setRank "SERGEANT" };
//         case "team leader": { _unit setRank "CORPORAL" };
//         default { _unit setRank "PRIVATE" };
//     };
    
//     _unit
// };

// // Process each squad in the platoon structure
// {
//     _x params ["_squadName", "_composition"];
//     private "_group";
    
//     // Check if group exists when replenishing
//     if (_replenish) then {
//         {
//             if ((_x getVariable ["DPC_SquadName", ""]) == _squadName) exitWith {
//                 _group = _x;
//             };
//         } forEach PLATOON_GROUPS;
//     };
    
//     // Create new group if needed
//     if (isNil "_group" || {isNull _group}) then {
//         _group = createGroup [west, true];
//         _group setVariable ["DPC_SquadName", _squadName, true];  // Added true for global broadcast
//         PLATOON_GROUPS pushBack _group;
//     };
    
//     // Create or replenish units
//     {
//         _x params ["_type", "_role"];
        
//         // Check if we need this role when replenishing
//         private _needUnit = true;
//         if (_replenish) then {
//             {
//                 if (alive _x && {_x getVariable ["DPC_Role", ""] == _role}) exitWith {
//                     _needUnit = false;
//                 };
//             } forEach (units _group);
//         };
        
//         // Create unit if needed
//         if (_needUnit) then {
//             [_type, _role, _group, _spawnPos] call _fnc_createUnit;
//         };
//     } forEach _composition;
    
//     // Basic group settings
//     _group enableDynamicSimulation true;
//     _group setFormation "WEDGE";
    
// } forEach _platoonStructure;

// // Return the groups array
// PLATOON_GROUPS
