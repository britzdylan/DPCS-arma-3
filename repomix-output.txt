This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-11T19:22:10.132Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
description.ext
functions/config/fn_initMissionConfig.sqf
functions/config/initPlatoonGroups.sqf
functions/debug/fn_dumpState.sqf
functions/init/fn_initPlatoonUnits.sqf
functions/medical/fn_addDragAction.sqf
functions/medical/fn_addLoadBodyAction.sqf
functions/medical/fn_addReviveAction.sqf
functions/medical/fn_addUnloadBodyAction.sqf
functions/medical/fn_canLoadBody.sqf
functions/medical/fn_handleUnitDeath.sqf
functions/medical/fn_initMedicalSystems.sqf
init.sqf
scripts/state/platoon_assets.sqf

================================================================
Files
================================================================

================
File: description.ext
================
class CfgConstants 
{
    // General Mission Settings
    MISSION_NAME = "Dynamic Platoon Command";
    MISSION_AUTHOR = "Dylan Britz";
    
    // Medical System Constants
    class Medical {
        REVIVE_TIME_LIMIT = 60;     // 5 minutes in seconds
        MAX_REVIVE_DISTANCE = 5;     // meters
        SKILL_PENALTY = 0.1;         // 10% skill reduction after revival
        MAX_CASEVAC_DISTANCE = 15;   // meters from medical building
        MAX_MEDICAL_FACILITY_CAPACITY = 2; // Number of patients that can be treated at once
    };

    // Resupply unit constants
    class Supply {
        TRACKED_VEHICLE_POOL = 1;
        MRAP_VEHICLE_POOL = 15;
        HMG_VEHICLE_POOL = 10;
        GMG_VEHICLE_POOL = 7;
        QUAD_POOL = 20;
        AMMO_TRUCK_POOL = 25;
        MED_TRUCK_POOL = 5;
        REPAIR_TRUCK_POOL = 5;
        FUEL_TRUCK_POOL = 12;
        HMG_TURRET_POOL = 55;
        GMG_TURRET_POOL = 25;
        AT_TURRET_POOL = 15;
        MORTAR_TURRET_POOL = 15;
    }
};

class CfgFunctions
{
    class DPC
    {
        tag = "DPC";

        class Config {
            file = "functions\config";
            class initMissionConfig {
                postInit = 1;
            };
        };
        
        class Medical
        {
            file = "functions\medical";
            class handleUnitDeath {};
            class addLoadBodyAction {};
            class addUnloadBodyAction {};
            class canLoadBody {};
            class addReviveAction {};
            class initMedicalSystems {
                postInit = 1;
            };
        };

        class Debug
        {
            file = "functions\debug";
            class dumpState {};
        }
    };
};

================
File: functions/config/fn_initMissionConfig.sqf
================
// File: functions\config\fn_initMissionConfig.sqf

// Initialize Global Mission State
if (isNil "MISSION_STATE") then {
    MISSION_STATE = createHashMap;
    publicVariable "MISSION_STATE";
};

if (isNil "PLATOON_ASSETS") then {
    PLATOON_ASSETS = createHashMap;
    publicVariable "PLATOON_ASSETS";
};

private _vehicleCapacities = createHashMap;
_vehicleCapacities set ["B_MRAP_01_F", 2];        // Hunter
_vehicleCapacities set ["B_MRAP_01_hmg_F", 2];    // Armed Hunter
_vehicleCapacities set ["B_MRAP_01_gmg_F", 2];    // Armed Hunter
_vehicleCapacities set ["B_APC_Tracked_01_rcws_F", 6];    // Panther
_vehicleCapacities set ["B_Truck_01_medical_F", 8];       // HEMTT Medical


PLATOON_ASSETS set ["vehicle_capacities", _vehicleCapacities];

// Wait for player to be ready

player addAction [
    "Dump Mission State",
    {
        [MISSION_STATE] call DPC_fnc_dumpState;
    }, 
    nil, 
    1.5, 
    true, 
    true, 
    "",
    "true", // Condition
    5 // Radius
];

player addAction [
    "Dump Platoon State", 
    {
        [PLATOON_ASSETS] call DPC_fnc_dumpState;
    }, 
    nil, 
    1.5, 
    true, 
    true, 
    "",
    "true", // Condition
    5 // Radius
];

================
File: functions/config/initPlatoonGroups.sqf
================
// // File: functions\config\fn_initPlatoonGroups.sqf

// /*
//     Author: Your Name
//     Description: Initializes or replenishes a NATO infantry platoon
    
//     Parameters:
//         _spawnPos: Array/Object - Position to spawn units [x,y,z] or object
//         _replenish: Boolean - True to check and replenish existing groups
    
//     Returns: Array of groups created/replenished
    
//     Example:
//     [getMarkerPos "platoon_start", false] call DPC_fnc_initPlatoonGroups;
// */

// params [
//     ["_spawnPos", [0,0,0], [[],objNull]],
//     ["_replenish", false, [false]]
// ];

// // NATO Infantry unit types
// #define UNIT_OFFICER "B_officer_F"
// #define UNIT_SQL "B_Soldier_SL_F"
// #define UNIT_TL "B_Soldier_TL_F"
// #define UNIT_MEDIC "B_medic_F"
// #define UNIT_AR "B_soldier_AR_F"
// #define UNIT_GREN "B_Soldier_GL_F"
// #define UNIT_LAT "B_soldier_LAT_F"
// #define UNIT_RADIO "B_Soldier_lite_F"

// // Platoon structure definitions
// private _platoonStructure = [
//     // HQ Squad - 4 men
//     [
//         "HQ", [
//             [UNIT_OFFICER, "Platoon Commander"],
//             [UNIT_MEDIC, "Platoon Medic"],
//             [UNIT_RADIO, "Platoon RTO"],
//             [UNIT_TL, "Platoon Sergeant"]
//         ]
//     ],
//     // Three identical infantry squads - 8 men each
//     [
//         "Alpha", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Bravo", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ],
//     [
//         "Charlie", [
//             [UNIT_SQL, "Squad Leader"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_GREN, "Grenadier"],
//             [UNIT_LAT, "AT Specialist"],
//             [UNIT_TL, "Team Leader"],
//             [UNIT_AR, "Automatic Rifleman"],
//             [UNIT_MEDIC, "Squad Medic"]
//         ]
//     ]
// ];

// // Convert spawn position
// _spawnPos = if (_spawnPos isEqualType objNull) then {
//     getPos _spawnPos
// } else {
//     _spawnPos
// };

// // Initialize platoon groups array if needed
// if (isNil "PLATOON_GROUPS" && !_replenish) then {
//     PLATOON_GROUPS = [];
// };

// // Function to create a single unit
// private _fnc_createUnit = {
//     params ["_type", "_role", "_group", "_pos"];
    
//     private _unit = _group createUnit [_type, _pos, [], 5, "NONE"];
//     _unit setRank "PRIVATE";
//     _unit setVariable ["DPC_Role", _role, true];  // Added true for global broadcast
    
//     // Set ranks based on role
//     switch (toLower _role) do {
//         case "platoon commander": { _unit setRank "LIEUTENANT" };
//         case "platoon sergeant": { _unit setRank "SERGEANT" };
//         case "squad leader": { _unit setRank "SERGEANT" };
//         case "team leader": { _unit setRank "CORPORAL" };
//         default { _unit setRank "PRIVATE" };
//     };
    
//     _unit
// };

// // Process each squad in the platoon structure
// {
//     _x params ["_squadName", "_composition"];
//     private "_group";
    
//     // Check if group exists when replenishing
//     if (_replenish) then {
//         {
//             if ((_x getVariable ["DPC_SquadName", ""]) == _squadName) exitWith {
//                 _group = _x;
//             };
//         } forEach PLATOON_GROUPS;
//     };
    
//     // Create new group if needed
//     if (isNil "_group" || {isNull _group}) then {
//         _group = createGroup [west, true];
//         _group setVariable ["DPC_SquadName", _squadName, true];  // Added true for global broadcast
//         PLATOON_GROUPS pushBack _group;
//     };
    
//     // Create or replenish units
//     {
//         _x params ["_type", "_role"];
        
//         // Check if we need this role when replenishing
//         private _needUnit = true;
//         if (_replenish) then {
//             {
//                 if (alive _x && {_x getVariable ["DPC_Role", ""] == _role}) exitWith {
//                     _needUnit = false;
//                 };
//             } forEach (units _group);
//         };
        
//         // Create unit if needed
//         if (_needUnit) then {
//             [_type, _role, _group, _spawnPos] call _fnc_createUnit;
//         };
//     } forEach _composition;
    
//     // Basic group settings
//     _group enableDynamicSimulation true;
//     _group setFormation "WEDGE";
    
// } forEach _platoonStructure;

// // Return the groups array
// PLATOON_GROUPS

================
File: functions/debug/fn_dumpState.sqf
================
// File: functions/debug/fn_dumpState.sqf

/*
    Author: Dylan Britz
    Description: Dumps the entire mission state to clipboard for debugging
    
    Parameters:
        _state: HashMap - The mission state hashmap to dump
    
    Returns: String - The formatted state dump text
    
    Example:
    [MISSION_STATE] call DPC_fnc_dumpState;
*/

params [["_state", createHashMap, [createHashMap]]];

private _text = "";

if (count _state == 0) then {
    hint "Mission State not initialized";
    _text = "ERROR: Mission State not initialized";
} else {
    private _stateKeys = keys _state;
    
    _text = "=== MISSION STATE DUMP ===\n";
    _text = _text + format["Timestamp: %1\n", [dayTime, "HH:MM:SS"] call BIS_fnc_timeToString];
    _text = _text + format["Number of Keys: %1\n\n", count _stateKeys];
    
    {
        private _key = _x;
        private _value = _state get _key;
        
        // Handle different value types
        switch (true) do {
            // Handle nested hashmaps
            case (_value isEqualType createHashMap): {
                _text = _text + format["=== %1 ===\n", _key];
                {
                    private _subKey = _x;
                    private _subValue = _value get _subKey;
                    _text = _text + format["  %1: %2\n", _subKey, str _subValue];
                } forEach (keys _value);
                _text = _text + "\n";
            };
            // Handle arrays
            case (_value isEqualType []): {
                _text = _text + format["%1: %2\n", _key, str _value];
            };
            // Handle objects
            case (_value isEqualType objNull): {
                _text = _text + format["%1: %2 (%3)\n", _key, typeOf _value, str _value];
            };
            // Handle everything else
            default {
                _text = _text + format["%1: %2\n", _key, str _value];
            };
        };
    } forEach _stateKeys;
    
    copyToClipboard _text;
    hint "Mission State dumped to clipboard";
};

// Return formatted text
_text

================
File: functions/init/fn_initPlatoonUnits.sqf
================
// File: functions\init\fn_initPlatoonUnits.sqf

/*
    Author: Your Name
    Description: Initializes platoon units into mission state and adds necessary event handlers
    
    Parameters:
        _groups: Array - Array of groups to initialize [group1, group2, ...]
    
    Returns: None
    
    Example:
    [PLATOON_GROUPS] call DPC_fnc_initPlatoonUnits;
*/

params [["_groups", [], [[]]]];

private _medicalState = MISSION_STATE get "sys_medical";
if (isNil "_medicalState") then {
    _medicalState = createHashMap;
    MISSION_STATE set ["sys_medical", _medicalState];
    _medicalState set ["dead_units", []];
};

// Get platoon state
private _platoonState = MISSION_STATE get "platoon";
if (isNil "_platoonState") then {
    _platoonState = createHashMap;
    MISSION_STATE set ["platoon", _platoonState];
    _platoonState set ["all_units", []];
    _platoonState set ["active_units", []];
};

// Process each group
{
    private _group = _x;
    private _groupUnits = units _group;
    
    // Add units to platoon state
    {
        private _unit = _x;
        
        // Skip if unit is already initialized
        if !(_unit getVariable ["DPC_initialized", false]) then {
            // Add to all units array if not already present
            if !(_unit in (_platoonState get "all_units")) then {
                (_platoonState get "all_units") pushBack _unit;
            };
            
            // Add to active units if alive
            if (alive _unit) then {
                (_platoonState get "active_units") pushBack _unit;
            };
            
            // Add death event handler
            if (!isPlayer _unit) then {
                private _handlerId = _unit addEventHandler ["Killed", {
                    params ["_unit"];
                    [_unit] call DPC_fnc_handleUnitDeath;
                }];
                _unit setVariable ["DPC_deathHandler", _handlerId];
            };
            
            // Mark as initialized
            _unit setVariable ["DPC_initialized", true];
            
            // Set additional unit variables as needed
            _unit setVariable ["DPC_originalGroup", group _unit];
            _unit setVariable ["DPC_originalRole", roleDescription _unit];
        };
    } forEach _groupUnits;
} forEach _groups;

// Debug output
// if (DPC_DEBUG) then {
//     private _totalUnits = count (_platoonState get "all_units");
//     private _activeUnits = count (_platoonState get "active_units");
//     systemChat format ["Platoon initialized: %1 total units, %2 active", _totalUnits, _activeUnits];
    
//     // Detailed debug dump
//     [MISSION_STATE] call DPC_fnc_dumpState;
// };

================
File: functions/medical/fn_addDragAction.sqf
================
// File: functions\medical\fn_addCarryAction.sqf
params ["_unit"];

_unit addAction [
    "Carry Body",
    {
        params ["_body", "_carrier"];
        
        // Store variables
        _carrier setVariable ["isCarrying", true, true];
        _body setVariable ["beingCarried", true, true];
        
        // Try different attachment approach
        [_body, _carrier] spawn {
            params ["_body", "_carrier"];
            
            // Make sure body is at ground level first
            private _pos = getPosATL _carrier;
            _body setPosATL [_pos select 0, _pos select 1, 0];
            sleep 0.1;
            
            // Now attach
            _body attachTo [_carrier, [0, 1, 0.1]];
            _body setDir 0;
            
            systemChat "Body attached"; // Debug message
        };
        
        // Add release action
        private _releaseId = _carrier addAction [
            "Release Body",
            {
                params ["_carrier", "_caller", "_actionId", "_body"];
                
                detach _body;
                _body setPosATL (getPosATL _body);
                _carrier removeAction _actionId;
                _carrier setAnimSpeedCoef 1;
                
                // Clear variables
                _carrier setVariable ["isCarrying", nil, true];
                _body setVariable ["beingCarried", nil, true];
                
                systemChat "Body released"; // Debug message
            },
            _body,
            20,
            true,
            true,
            "",
            "true"
        ];
        
        // Slow down carrier slightly
        _carrier setAnimSpeedCoef 0.8;
        
        systemChat "Started carry action"; // Debug message
    },
    nil,
    20,
    true,
    true,
    "",
    // Make sure body isn't already being carried
    "!(_target getVariable ['beingCarried', false]) && !(_this getVariable ['isCarrying', false])"
];

================
File: functions/medical/fn_addLoadBodyAction.sqf
================
// File: functions\medical\fn_addLoadBodyAction.sqf
params ["_vehicle"];

// Get vehicle capacity
private _vehicleType = typeOf _vehicle;
private _maxCasualties = (PLATOON_ASSETS get "vehicle_capacities") getOrDefault [_vehicleType, 2];

_vehicle setVariable ["maxCasualties", _maxCasualties, true];

_vehicle addAction [
    "Load Casualty",
    {
        params ["_vehicle", "_caller", "_actionId", "_deadUnit"];
        
        private _deadUnits = MISSION_STATE get "sys_medical" get "dead_units";
        private _nearestDead = objNull;
        private _casualties = _vehicle getVariable ["loadedCasualties", []];
        private _maxCasualties = _vehicle getVariable ["maxCasualties", 2];
        
        // Check if vehicle is full
        if (count _casualties >= _maxCasualties) exitWith {
            systemChat format ["Vehicle is full! Maximum capacity: %1", _maxCasualties];
        };
        
        // Find nearest dead unit that isn't already loaded
        {
            if ([_x, _vehicle] call DPC_fnc_canLoadBody && !(_x in _casualties)) exitWith {
                _nearestDead = _x;
            };
        } forEach _deadUnits;
        
        if (!isNull _nearestDead) then {
            _nearestDead hideObject true;
            _casualties pushBack _nearestDead;
            
            // Update vehicle variables
            _vehicle setVariable ["loadedCasualties", _casualties, true];
            _vehicle setVariable ["casualtyCount", count _casualties, true];
            
            // Add unload action if not already present
            if (_vehicle getVariable ["unloadActionId", -1] == -1) then {
                [_vehicle] call DPC_fnc_addUnloadBodyAction;
            };
            
            // Debug output
            systemChat format ["Vehicle now has %1/%2 casualties", count _casualties, _maxCasualties];
            
            // Remove load action if full
            if (count _casualties >= _maxCasualties) then {
                _vehicle removeAction _actionId;
            };
        };
    },
    nil,
    1.5,
    true,
    true,
    "",
    "!isNil 'MISSION_STATE' && {count (nearestObjects [_target, ['Man'], 10] select {_x in (MISSION_STATE get 'sys_medical' get 'dead_units') && !(_x in (_target getVariable ['loadedCasualties', []]))}) > 0} && {count (_target getVariable ['loadedCasualties', []]) < (_target getVariable ['maxCasualties', 2])}"
];

================
File: functions/medical/fn_addReviveAction.sqf
================
// File: functions\medical\fn_addReviveAction.sqf
params ["_building"];

// Set maximum number of simultaneous treatments
private _maxTreatments = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "MAX_MEDICAL_FACILITY_CAPACITY");
private _casevacDistance = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "MAX_CASEVAC_DISTANCE");
private _reviveTime = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME_LIMIT");
private _skillPenalty = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "SKILL_PENALTY");

_building addAction [
    "Begin Medical Treatment",
    {
        params ["_building", "_caller", "_actionId"];
        private _reviveTime = _this select 3 select 0;
        private _skillPenalty = _this select 3 select 1;
        private _casevacDistance = _this select 3 select 2;
        private _maxTreatments = _this select 3 select 3;
        
        // Count current treatments
        private _currentTreatments = count ((nearestObjects [_building, ["Man"], 5]) select {
            !isNil {_x getVariable "reviveProgress"}
        });
        
        // Get all dead units near building not already being treated
        private _nearbyDead = (nearestObjects [_building, ["Man"], _casevacDistance]) select {
            _x in (MISSION_STATE get "sys_medical" get "dead_units") &&
            isNil {_x getVariable "reviveProgress"}
        };
        
        // Calculate how many more we can treat
        private _availableSlots = _maxTreatments - _currentTreatments;
        
        if (_availableSlots <= 0) exitWith {
            systemChat "Medical facility at maximum capacity (2 patients)";
        };
        
        if (count _nearbyDead > 0) then {
            // Limit number of new treatments to available slots
            private _unitsToTreat = _nearbyDead select [0, _availableSlots];
            
            // Start revival process for each dead unit
            {
                private _deadUnit = _x;
                
                // Start revival process and pass the needed variables
                [_deadUnit, _building, _reviveTime, _skillPenalty] spawn {
                    params ["_unit", "_building", "_reviveTime", "_skillPenalty"];
                    private _startTime = time;
                    
                    // Create progress tracking variable
                    _unit setVariable ["reviveProgress", 0, true];
                    
                    // Progress loop
                    while {time - _startTime < _reviveTime} do {
                        // Update progress
                        private _progress = ((time - _startTime) / _reviveTime) * 100;
                        _unit setVariable ["reviveProgress", _progress, true];
                        
                        // Display progress for each unit
                        systemChat format ["%1 Treatment Progress: %2%3", name _unit, floor _progress, "%"];
                        sleep 5; // Update every 5 seconds
                    };
                    
                    // Revival complete
                    // Remove from dead units
                    private _deadUnits = MISSION_STATE get "sys_medical" get "dead_units";
                    _deadUnits = _deadUnits - [_unit];
                    (MISSION_STATE get "sys_medical") set ["dead_units", _deadUnits];
                    
                    // Revive unit
                    _unit setDamage 0;
                    _unit setUnconscious false;
                    _unit allowDamage true;
                    _unit enableAI "ALL"; // Re-enable AI
                    [_unit] joinSilent group player;
                    
                    // set skill penalty
                    _unit setSkill ((skill _unit) - _skillPenalty);
                    
                    // Reset death time (do this before clearing reviveProgress)
                    _unit setVariable ["deathTime", nil, true];
                    
                    // Notify success
                    systemChat format ["%1 has been revived", name _unit];
                    
                    // Clear variables, do not set ot nil. This is important for the condition check
                    _unit setVariable ["reviveProgress", nil, true];
                };
            } forEach _unitsToTreat;
            
            systemChat format ["Beginning treatment of %1 casualties", count _unitsToTreat];
        } else {
            systemChat "No casualties within range of medical facility";
        };
    },
    [_reviveTime, _skillPenalty, _casevacDistance, _maxTreatments],  // Pass these variables as arguments
    1.5,
    true,
    true,
    "",
    // Condition: Check for any nearby dead units not being treated AND facility not at capacity
    format ["private _currentTreatments = count ((nearestObjects [_target, ['Man'], 5]) select {!isNil {_x getVariable 'reviveProgress'}}); _currentTreatments < %1 && {count ((nearestObjects [_target, ['Man'], %2]) select {_x in (MISSION_STATE get 'sys_medical' get 'dead_units') && isNil {_x getVariable 'reviveProgress'}}) > 0}", _maxTreatments, _casevacDistance]
];

================
File: functions/medical/fn_addUnloadBodyAction.sqf
================
// File: functions\medical\fn_addUnloadBodyAction.sqf
params ["_vehicle"];

// Only add if action doesn't exist
if (_vehicle getVariable ["unloadActionId", -1] == -1) then {
    private _actionId = _vehicle addAction [
        "Unload Casualty",
        {
            params ["_vehicle", "_caller"];
            private _casualties = _vehicle getVariable ["loadedCasualties", []];
            private _maxCasualties = _vehicle getVariable ["maxCasualties", 2];
            
            if (count _casualties > 0) then {
                private _casualty = _casualties select 0;  // Get first casualty
                private _pos = _vehicle modelToWorld [0, -5, 0];
                
                // Remove from array and update count
                _casualties deleteAt 0;
                _vehicle setVariable ["loadedCasualties", _casualties, true];
                _vehicle setVariable ["casualtyCount", count _casualties, true];
                
                // Show casualty
                _casualty setPos _pos;
                _casualty hideObject false;
                
                // Debug output
                systemChat format ["Vehicle now has %1/%2 casualties", count _casualties, _maxCasualties];
                
                // Re-add load action if we were previously full
                if ((count _casualties) + 1 >= _maxCasualties) then {
                    [_vehicle] call DPC_fnc_addLoadBodyAction;
                };
                
                // Remove unload action if no more casualties
                if (count _casualties == 0) then {
                    _vehicle removeAction (_vehicle getVariable "unloadActionId");
                    _vehicle setVariable ["unloadActionId", -1, true];
                };
            };
        },
        nil,
        1.5,
        true,
        true,
        "",
        "count (_target getVariable ['loadedCasualties', []]) > 0"
    ];
    
    // Store the action ID
    _vehicle setVariable ["unloadActionId", _actionId, true];
};

================
File: functions/medical/fn_canLoadBody.sqf
================
params ["_unit", "_vehicle"];

// Check if unit is in dead_units and within range: 10m
(!isNil "MISSION_STATE") &&
{_unit in (MISSION_STATE get "sys_medical" get "dead_units")} && 
{_unit distance _vehicle < 10}

================
File: functions/medical/fn_handleUnitDeath.sqf
================
// File: functions\medical\fn_handleUnitDeath.sqf
params ["_unit"];

if(!isNil "MISSION_STATE") then {
    private _medicalState = MISSION_STATE get "sys_medical";
    private _deadUnits = _medicalState get "dead_units";
    private _reviveTime = getNumber(missionConfigFile >> "CfgConstants" >> "Medical" >> "REVIVE_TIME_LIMIT");

    if (!isPlayer _unit) then {
        _unit allowDamage false;
        _unit setUnconscious true;
        _unit disableAI "ALL";
        _unit setVariable ["deathTime", time];
        _deadUnits pushBack _unit;

        [_unit, _reviveTime] spawn {
            params ["_unit", "_reviveTime"];
            private _deathTime = _unit getVariable "deathTime";

            // Add drag action to dead unit
            // [_unit] call DPC_fnc_addDragAction;
            
            waitUntil {
                sleep 1;
                if (!isNil "_deathTime" && 
                    (time - _deathTime >= _reviveTime) && 
                    {isNil {_unit getVariable "reviveProgress"}}) then {
                    private _medicalState = MISSION_STATE get "sys_medical";
                    private _deadUnits = _medicalState get "dead_units";
                    _deadUnits = _deadUnits - [_unit];
                    _medicalState set ["dead_units", _deadUnits];
                    _unit allowDamage true;
                    _unit setUnconscious false;
                    _unit enableAI "ALL";
                    _unit setDamage 1;
                    true
                } else {
                    false
                };
            };
        };
    };
};

================
File: functions/medical/fn_initMedicalSystems.sqf
================
// File: functions\medical\fn_initMedicalSystem.sqf
// Initialize medical state if not exists
if (isNil {MISSION_STATE get "sys_medical"}) then {
    MISSION_STATE set ["sys_medical", createHashMap];
    (MISSION_STATE get "sys_medical") set ["dead_units", []];
};

// Add death handlers to all existing units
{
    if (!isPlayer _x && {(_x getVariable ["DPC_deathHandler", -1]) == -1}) then {
        private _handlerId = _x addEventHandler ["HandleDamage", {
               params ["_unit", "_selection", "_damage", "_source", "_projectile", "_hitIndex", "_instigator", "_hitPoint"];
                if (_damage >= 0.9) then {
                    [_unit] call DPC_fnc_handleUnitDeath;
                };
            }];
        _x setVariable ["DPC_deathHandler", _handlerId];
    };
} forEach (allUnits select {side _x == playerSide});

// Add load actions to appropriate vehicles
{
    if (_x isKindOf "Car" || _x isKindOf "Tank" || _x isKindOf "Air") then {
        [_x] call DPC_fnc_addLoadBodyAction;
    };
} forEach vehicles;

[trauma_unit] call DPC_fnc_addReviveAction;

================
File: init.sqf
================
// [] spawn {
//     [] execVM "scripts\state\platoon_assets.sqf";
// };

hint "Script Complete";

================
File: scripts/state/platoon_assets.sqf
================
PLATOON_ASSETS set ["veh_supply", createHashMap];
PLATOON_ASSETS set ["combat_vehicles", createHashMap];
PLATOON_ASSETS set ["transport_vehicles", createHashMap];
PLATOON_ASSETS set ["utility_vehicles", createHashMap];
PLATOON_ASSETS set ["turrets", createHashMap];

private _trackedVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "TRACKED_VEHICLE_POOL");
private _mrapVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MRAP_VEHICLE_POOL");
private _hmgVehiclePool =  getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "HMG_VEHICLE_POOL");
private _gmgVehiclePool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "GMG_VEHICLE_POOL");
private _quadPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "QUAD_POOL");
private _ammoTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "AMMO_TRUCK_POOL"); 
private _medTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MED_TRUCK_POOL"); 
private _repairTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "REPAIR_TRUCK_POOL"); 
private _fuelTruckPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "FUEL_TRUCK_POOL"); 
private _hmgTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "HMG_TURRET_POOL"); 
private _gmgTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "GMG_TURRET_POOL"); 
private _atTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "AT_TURRET_POOL"); 
private _mortarTurretPool = getNumber(missionConfigFile >> "CfgConstants" >> "Supply" >> "MORTAR_TURRET_POOL"); 

/*
#######################
#####
# Supply
#####
#######################
*/

private _veh_supply = PLATOON_ASSETS get "veh_supply";
_veh_supply set ["spawn_point", [14750.6,17085.3]];
_veh_supply set ["last_used", 0];
_veh_supply set ["cooldown", 60];

/*
#######################
#####
# Combat Vehicles
#####
#######################
*/

(PLATOON_ASSETS get "combat_vehicles") set ["pool", createHashMap];

private _com_pool = (PLATOON_ASSETS get "combat_vehicles") get "pool";
// [vehicle class, available units, active units]
_com_pool set ["B_APC_Tracked_01_rcws_F",[_trackedVehiclePool, 1]];
_com_pool set ["B_MRAP_01_hmg_F", [_hmgVehiclePool, 3]];
_com_pool set ["B_MRAP_01_gmg_F",[_gmgVehiclePool, 1]];

/*
#######################
#####
# Transport Vehicles
#####
#######################
*/

(PLATOON_ASSETS get "transport_vehicles") set ["pool", createHashMap];

private _trans_pool = (PLATOON_ASSETS get "transport_vehicles") get "pool";
_trans_pool set ["B_Quadbike_01_F", [_quadPool, 2]];
_trans_pool set ["B_MRAP_01_F", [_mrapVehiclePool, 2]];

/*
#######################
#####
# Utility Vehicles
#####
#######################
*/

(PLATOON_ASSETS get "utility_vehicles") set ["pool", createHashMap];

private _util_pool = (PLATOON_ASSETS get "utility_vehicles") get "pool";
_util_pool set ["B_Truck_01_ammo_F", [_ammoTruckPool, 1]];
_util_pool set ["B_Truck_01_medical_F",[_medTruckPool, 1]];
_util_pool set ["B_Truck_01_Repair_F",[_repairTruckPool, 1]];
_util_pool set ["B_Truck_01_fuel_F",[_fuelTruckPool, 1]];

/*
#######################
#####
# Turrets
#####
#######################
*/

(PLATOON_ASSETS get "turrets") set ["pool", createHashMap];

private _tur_pool = (PLATOON_ASSETS get "turrets") get "pool";
_tur_pool set ["B_HMG_01_high_F", [_hmgTurretPool, 3]];
_tur_pool set ["B_GMG_01_high_F", [_gmgTurretPool, 2]];
_tur_pool set ["B_static_AT_F", [_atTurretPool, 3]];
_tur_pool set ["B_Mortar_01_F", [_mortarTurretPool, 2]];

publicVariable "PLATOON_ASSETS";
